См. исходники и дополнения (ENG): https://reflectoring.io/spring-boot-starter/
________________________________________________________________________________________________________________________
### Разбиение Spring Boot приложения на модули

Каждый программный проект подходит к моменту, когда код необходимо разбить на модули. Это могут быть модули внутри
одной кодовой базы или модули, каждый из которых живет в своей собственной кодовой базе. В этой статье объясняются
некоторые функции Spring Boot, которые помогают разделить приложение Spring Boot на несколько модулей.

Пример [кода на GitHub](https://github.com/thombergs/code-examples/tree/master/spring-boot/modular)

________________________________________________________________________________________________________________________
#### Что такое модуль в Spring Boot?

Модуль в понимании этой статьи — это набор компонентов Spring, загружаемых в контекст приложения.

Модуль может быть бизнес-модулем, предоставляющим некоторые бизнес-услуги приложению, или техническим модулем,
обеспечивающим сквозную работу нескольких других модулей или всего приложения. Модули, обсуждаемые в этой статье,
являются частью одной и той же монолитной кодовой базы. Чтобы лучше обеспечить соблюдение границ модулей, мы
могли бы разделить эту монолитную кодовую базу на несколько модулей сборки с помощью Maven или Gradle, если мы
того пожелаем - https://reflectoring.io/spring-boot-gradle-multi-module/.

________________________________________________________________________________________________________________________
#### Варианты создания модулей

Основой модуля Spring является @Configuration аннотированный класс, аналогичный функции конфигурации Java Spring.
Существует несколько способов определить, какие [bean-компоненты должны быть загружены таким классом конфигурации](https://docs.spring.io/spring-framework/reference/core/beans/java.html).

________________________________________________________________________________________________________________________
#### @ComponentScan

Самый простой способ создать модуль — использовать аннотацию @ComponentScan к классу конфигурации:

            @Configuration
            @ComponentScan(basePackages = "io.reflectoring.booking")
            public class BookingModuleConfiguration {
            }

Если этот класс конфигурации выбран одним из механизмов импорта (описано ниже), он просмотрит все классы в пакете
io.reflectoring.booking и загрузит экземпляр каждого класса, который помечен [одной из стереотипных аннотаций Spring,
в контекст приложения](https://github.com/spring-projects/spring-framework/tree/main/spring-context/src/main/java/org/springframework/stereotype).

Этот способ подходит, если вы всегда хотите загружать все классы пакета и его подпакеты в контекст приложения. Если
вам нужно больше контроля над тем, что загружать, читайте дальше.

________________________________________________________________________________________________________________________
#### Определения @Bean

Функция конфигурации Java в Spring также предоставляет @Bean аннотацию для создания bean-компонентов, загружаемых в
контекст приложения:

            @Configuration
            public class BookingModuleConfiguration {
            
              @Bean
              public BookingService bookingService(){
                return new BookingService();
              }
            
              // potentially more @Bean definitions ...
            
            }

Когда этот класс конфигурации импортируется, экземпляр BookingService будет создан и вставлен в контекст приложения.
Использование этого способа создания модуля дает более четкое представление о том, какие bean-компоненты на самом деле
загружены, поскольку у вас есть одно место для просмотра - в отличие от использования, @ComponentScan когда вам нужно
смотреть на стереотипные аннотации всех классов в пакете, чтобы увидеть, что происходит.

________________________________________________________________________________________________________________________
#### Аннотации @ConditionalOn...

Если вам нужен еще более детальный контроль над тем, какие компоненты следует загружать в контекст приложения, вы
можете использовать @ConditionalOn... аннотации Spring Boot:

            @Configuration
            @ConditionalOnProperty(name = "io.reflectoring.security.enabled",
                                   havingValue = "true",
                                   matchIfMissing = true)
            public class SecurityModuleConfiguration {
              // @Bean definitions ...
            }

Установка свойства io.reflectoring.security.enabled теперь - false полностью отключит этот модуль.

Существуют и другие @ConditionalOn...аннотации, которые вы можете использовать для определения условий загрузки модуля.
К ним относятся условие, зависящее от версии JVM и существования определенного класса в пути к классам или определенного
bean-компонента в контексте приложения, см. https://reflectoring.io/spring-boot-conditionals/

Если вы когда-нибудь задавались вопросом, как Spring Boot волшебным образом загружает именно те bean-компоненты, которые
нужны вашему приложению, в контекст приложения, то вот как. Сам Spring Boot активно использует аннотации
@ConditionalOn...

________________________________________________________________________________________________________________________
#### Варианты импорта модулей

Создав модуль, нам необходимо импортировать его в приложение.

________________________________________________________________________________________________________________________
#### @Import

Самый простой способ — использовать аннотацию @Import:

            @SpringBootApplication
            @Import(BookingModuleConfiguration.class)
            public class ModularApplication {
              // ...
            }

Это приведет к импорту класса BookingModuleConfiguration и всех связанных с ним bean-компонентов - независимо от того,
объявлены ли они с помощью аннотаций @ComponentScan или @Bean.

________________________________________________________________________________________________________________________
#### Аннотации @Enable...

Spring Boot предоставляет набор аннотаций, каждая из которых импортирует определенный модуль. Примером является,
аннотация @EnableScheduling которая импортирует все Bean-компоненты, необходимые для работы подсистемы планирования и
ее аннотаций @Scheduled.

Мы можем использовать это сами, определив собственную аннотацию @EnableBookingModule:

            @Retention(RetentionPolicy.RUNTIME)
            @Target({ElementType.TYPE})
            @Documented
            @Import(BookingModuleConfiguration.class)
            @Configuration
            public @interface EnableBookingModule {
            }

Аннотация используется следующим образом:

            @SpringBootApplication
            @EnableBookingModule
            public class ModularApplication {
             // ...
            }

Аннотация @EnableBookingModule на самом деле является просто оберткой вокруг аннотации @Import, которая импортирует наш
объект, BookingModuleConfiguration как и раньше. Однако если у нас есть модуль, состоящий более чем из одной
конфигурации, это удобный и выразительный способ объединить эти конфигурации в один модуль.

________________________________________________________________________________________________________________________
#### Авто-конфигурация

Если мы хотим загрузить модуль автоматически вместо жесткого связывания импорта с исходным кодом, мы можем использовать
функцию автоматической настройки Spring Boot.

Чтобы включить модуль для автоматической настройки, поместите файл META-INF/spring.factories в путь к классам:

            org.springframework.boot.autoconfigure.EnableAutoConfiguration = io.reflectoring.security.SecurityModuleConfiguration

Это импортирует класс SecurityModuleConfiguration и все его компоненты в контекст приложения.

Автоматическая настройка особенно удобна, если мы создаем сквозную задачу, которая будет использоваться во многих
приложениях Spring Boot. В этом случае мы можем даже построить на основе конфигурации отдельный стартовый модуль.

________________________________________________________________________________________________________________________
#### Настройка модуля

Благодаря @ConfigurationProperties аннотации Spring Boot обеспечивает первоклассную поддержку для привязки внешних
параметров конфигурации к bean-компоненту Spring типобезопасным способом, см.
https://reflectoring.io/spring-boot-configuration-properties/

________________________________________________________________________________________________________________________
#### Когда использовать какую стратегию импорта?

В этой статье представлены основные возможности создания и импорта модулей в приложении Spring Boot. Но когда нам
следует использовать какой из этих вариантов?

________________________________________________________________________________________________________________________
#### Использование @Import для бизнес-модулей

Для модулей, содержащих бизнес-логику, таких, как BookingModuleConfiguration из приведенных выше фрагментов кода, в
большинстве случаев достаточно статического импорта с аннотацией @Import. Обычно не имеет смысла не загружать
бизнес-модуль, поэтому нам не требуется никакого контроля над условиями его загрузки.

        !!! Обратите внимание: даже если модуль всегда загружен, он все равно имеет право существовать как модуль, поскольку,
                               будучи модулем, он может жить в своем собственном пакете или даже в своем собственном JAR-файле.

________________________________________________________________________________________________________________________
#### Используйте автоматическую настройку для технических модулей

С другой стороны, технические модули, как и SecurityModuleConfiguration вышеописанные, обычно обеспечивают некоторые
сквозные задачи, такие как ведение журнала, обработка исключений, авторизация или функции мониторинга, без которых
приложение вполне может обойтись. Эти функции могут быть вообще нежелательны, особенно во время разработки, поэтому
мы хотим иметь возможность их отключить.

Кроме того, мы не хотим статически импортировать каждый технический модуль с помощью @Import, поскольку они не должны
оказывать никакого влияния на наш код.

Итак, лучший вариант импорта технических модулей — функция авто-настройки. Модули загружаются автоматически в фоновом
режиме, и мы можем влиять на них вне кода с помощью свойств.