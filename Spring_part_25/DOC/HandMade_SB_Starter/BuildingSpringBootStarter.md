См. исходники и дополнения (ENG): https://reflectoring.io/spring-boot-starter/
________________________________________________________________________________________________________________________
### Краткое руководство по созданию Spring Boot Starter-a

Существуют определенные стандартные сквозные задачи (cross-cutting concerns), которые мы не хотим реализовывать с нуля
для каждого приложения Spring Boot, которое мы создаем. Вместо этого мы хотим реализовать эти функции один раз и
включать их в любое приложение по мере необходимости.

В Spring Boot для модуля, который обеспечивает такие сквозные задачи, используется термин «стартер». Стартер позволяет
легко включить определенный набор функций во вновь созданное приложение, чтобы сразу «начать» с ними работать.

Некоторые примеры использования стартера Spring Boot:
- предоставление настраиваемой конфигурации журнала (logging) и/или конфигурации по умолчанию или упрощение входа на
  центральный сервер журналов (log);
- предоставление настраиваемой конфигурации безопасности и/или конфигурации безопасности (security) по-умолчанию;
- предоставление настраиваемой стратегии обработки ошибок и/или стратегии обработки ошибок (error, exception)
  по-умолчанию;
- предоставление адаптера к центральной инфраструктуре обмена сообщениями (messaging);
- интеграция сторонней библиотеки и возможность ее настройки для использования со Spring Boot;
- и т.д.

В этой статье мы создадим версию Spring Boot Starter, которая позволит приложению Spring Boot легко отправлять и
получать события через воображаемую центральную инфраструктуру обмена сообщениями.

________________________________________________________________________________________________________________________
Пример рабочего кода на GitHub - https://github.com/thombergs/code-examples/tree/master/spring-boot/starter.
________________________________________________________________________________________________________________________

#### Словарный запас Spring Boot Starter ***

Прежде чем мы углубимся в детали создания стартера Spring Boot, давайте обсудим некоторые ключевые слова, которые
помогут понять работу стартера:

- Контекст приложения: В приложении Spring контекст приложения - это сеть объектов (или «bean»), составляющих приложение.
                       Он содержит наши веб-контроллеры, службы, репозитории и любые объекты (обычно без сохранения
                       состояния), которые могут нам понадобиться для работы нашего приложения.

- Конфигурация Spring: Класс, помеченный аннотацией @Configuration, служит фабрикой для bean-компонентов, которые
                       добавляются в контекст приложения. Он может содержать фабричные методы, аннотированные @Bean
                       возвращаемыми значениями которых Spring автоматически добавляется в контекст приложения.

                       Короче говоря, конфигурация Spring вносит bean-компоненты в контекст приложения.

- Авто-конфигурация: Это @Configuration класс, который автоматически обнаруживается Spring-ом. Как только в пути к
                     классам обнаруживается авто-конфигурация, она оценивается, и вклад конфигурации добавляется в
                     контекст приложения.

                     Авто-конфигурация может быть условной - https://reflectoring.io/spring-boot-conditionals/, так
                     что ее активация зависит от внешних факторов, таких как определенный параметр конфигурации,
                     имеющий определенное значение.

- Модуль автоматической настройки: Это модуль Maven или Gradle, который содержит класс авто-конфигурации. Таким образом,
                                   мы можем создавать модули, которые автоматически вносят вклад в контекст приложения,
                                   добавляя определенную функцию или предоставляя доступ к определенной внешней
                                   библиотеке.

                                   Все, что нам нужно сделать, чтобы использовать его в нашем Spring Boot приложении -
                                   это включить зависимость от него в наш pom.xml или build.gradle файл. Этот метод
                                   активно используется командой Spring Boot для интеграции Spring Boot с внешними
                                   библиотеками.

- Spring Boot Starter: Это модуль Maven или Gradle, единственной целью которого является предоставление всех
                       зависимостей, необходимых для «начала работы» с определенной функцией. Обычно это означает,
                       что это отдельный pom.xml или build.gradle файл, содержащий зависимости от одного или нескольких
                       модулей автоматической настройки, а также любые другие зависимости, которые могут потребоваться.

                       В приложении Spring Boot нам нужно только включить этот стартер, чтобы использовать эту функцию.

________________________________________________________________________________________________________________________
#### Объединение авто-конфигурации и стартера в одном модуле

В справочном руководстве предлагается разделить авто-конфигурацию и запуск на отдельные модули Maven или Gradle, чтобы
отделить задачи автоматической настройки от задач управления зависимостями [docs.spring.io](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration).

Это может быть немного перегружено в средах, где мы не создаем библиотеку с открытым исходным кодом, которую используют
тысячи пользователей. В этой статье мы объединим обе проблемы в один Starter модуль.

________________________________________________________________________________________________________________________
#### Создание стартового устройства для обмена сообщениями о событиях

Давайте узнаем, как реализовать стартер, на примере.

Представьте, что мы работаем в среде микросервисов и хотим реализовать стартер, который позволит службам
взаимодействовать друг с другом асинхронно. Стартер, который мы создаем, будет обеспечивать следующие возможности:
- компонент EventPublisher, который позволяет нам отправлять события в центральную инфраструктуру обмена сообщениями;
- абстрактный EventListener класс, который можно реализовать для подписки на определенные события из центральной
  инфраструктуры обмена сообщениями;

Обратите внимание, что реализация в этой статье на самом деле не будет подключаться к центральной инфраструктуре обмена
сообщениями, а вместо этого предоставит фиктивную реализацию. Цель этой статьи - продемонстрировать, как создать
версию Spring Boot Starter, а не как обмениваться сообщениями.

________________________________________________________________________________________________________________________
#### Настройка сборки Gradle

Поскольку стартер является сквозной задачей для нескольких приложений Spring Boot, он должен находиться в собственной
кодовой базе (иметь собственное кодовое ядро) и иметь собственный модуль Maven или Gradle. В качестве инструмента сборки
мы будем использовать Gradle, но с Maven он работает очень похоже.

Чтобы включить основные функции Spring Boot в наш стартер, нам нужно объявить зависимость от базового стартера
Spring Boot в нашем [build.gradle](https://github.com/thombergs/code-examples/blob/master/spring-boot/starter/event-starter/build.gradle) файле:

        plugins {
            id 'io.spring.dependency-management' version '1.0.8.RELEASE'
            id 'java'
        }
        
        group = 'io.reflectoring'
        version = '0.0.1-SNAPSHOT'
        sourceCompatibility = '11'
        
        repositories {
            mavenCentral()
        }
        
        dependencyManagement {
            imports {
                mavenBom("org.springframework.boot:spring-boot-dependencies:2.1.7.RELEASE")
            }
        }
        
        dependencies {
            implementation 'org.springframework.boot:spring-boot-starter'
        
            annotationProcessor 'org.springframework.boot:spring-boot-autoconfigure-processor'
            annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
        
            testImplementation 'org.springframework.boot:spring-boot-starter-test'
        
            compileOnly('org.projectlombok:lombok:1.18.2')
            annotationProcessor 'org.projectlombok:lombok:1.18.2'
        }
        
        compileJava.dependsOn(processResources)

Чтобы получить версию базового стартера, совместимую с определенной версией Spring Boot, мы используем плагин Spring
Dependency Management, чтобы включить спецификацию (спецификацию материалов) этой конкретной версии.

Таким образом, Gradle ищет совместимую версию стартера (и версии любых других зависимостей, которые нужны Spring Boot)
в этой спецификации, и нам не нужно объявлять ее вручную.

________________________________________________________________________________________________________________________
#### Обеспечение автоматической настройки

В качестве точки входа в возможности нашего стартера мы предоставляем @Configuration класс:

        @Configuration
        class EventAutoConfiguration {
        
          @Bean
          EventPublisher eventPublisher(List<EventListener> listeners){
            return new EventPublisher(listeners);
          }
        }

Эта конфигурация включает в себя все @Bean определения, необходимые для обеспечения функций нашего стартера. В этом
случае мы просто добавляем EventPublisher компонент в контекст приложения. Наша фиктивная реализация EventPublisher
должна знать все EventListeners, чтобы доставлять им события, поэтому мы позволяем Spring внедрить список всех
EventListeners доступных в контексте приложения.

Чтобы сделать нашу конфигурацию автоматической, мы перечислим ее в файле META-INF/spring.factories:

        org.springframework.boot.autoconfigure.EnableAutoConfiguration = io.reflectoring.starter.EventAutoConfiguration

Spring Boot просматривает все spring.factories файлы, которые находит в пути к классам, и загружает объявленные внутри
конфигурации. Теперь, когда EventAutoConfiguration класс готов, у нас есть автоматически активируемая единая точка входа
для нашего стартера Spring Boot.

________________________________________________________________________________________________________________________
#### Сделать стартер необязательным (Optional)

Всегда полезно разрешить отключение функций стартера Spring Boot. Это особенно важно при предоставлении доступа к
внешней системе, такой как служба обмена сообщениями. Например, эта служба не будет доступна в тестовой среде, поэтому
мы хотим отключить эту функцию на время тестирования.

Мы можем сделать конфигурацию нашей точки входа необязательной, используя условные аннотации Spring Boot
(см. https://reflectoring.io/spring-boot-conditionals/) :

        @Configuration
        @ConditionalOnProperty(value = "eventstarter.enabled", havingValue = "true")
        @ConditionalOnClass(name = "io.reflectoring.KafkaConnector")
        class EventAutoConfiguration {
          ...
        }

Используя, ConditionalOnProperty мы говорим Spring включать EventAutoConfiguration (и все объявленные им bean-компоненты)
в контекст приложения только в том случае, если для свойства eventstarter.enabled установлено значение - true.

Аннотация @ConditionalOnClass сообщает Spring, что следует активировать авто-конфигурацию только тогда, когда класс
io.reflectoring.KafkaConnector находится в пути к классам (это просто фиктивный класс, демонстрирующий использование
условных аннотаций).

________________________________________________________________________________________________________________________
#### Сделать стартер настраиваемым

Для библиотеки, которая используется в нескольких приложениях, таких как наш стартер, также хорошей идеей будет сделать
ее поведение максимально настраиваемой. Представьте, что приложение интересуется только определенными событиями. Чтобы
сделать это настраиваемым для каждого приложения, мы могли бы предоставить список включенных событий в файле
application.yml (или application.properties):

        eventstarter:
          listener:
            enabled-events:
              - foo
              - bar

Чтобы сделать эти свойства легко доступными в коде нашего стартера, мы можем предоставить @ConfigurationProperties класс
(https://reflectoring.io/spring-boot-configuration-properties/) :

        @ConfigurationProperties(prefix = "eventstarter.listener")
        @Data
        class EventListenerProperties {
        
          /*
          Список типов событий, которые будут переданы {@link EventListener}
          реализации. Все остальные события будут игнорироваться.
          */
          private List<String> enabledEvents = Collections.emptyList();
        
        }

Мы активируем класс EventListenerProperties, аннотируя нашу конфигурацию точки входа с помощью 
@EnableConfigurationProperties:

        @Configuration
        @EnableConfigurationProperties(EventListenerProperties.class)
        class EventAutoConfiguration {
          ...
        }

И, наконец, мы можем позволить Spring внедрить компонент EventListenerProperties куда угодно, например, в наш
абстрактный класс EventListener, чтобы отфильтровать события, которые нас не интересуют:

        @RequiredArgsConstructor
        public abstract class EventListener {
        
          private final EventListenerProperties properties;
        
          public void receive(Event event) {
            if(isEnabled(event) && isSubscribed(event)){
              onEvent(event);
            }
          }
        
          private boolean isSubscribed(Event event) {
            return event.getType().equals(getSubscribedEventType());
          }
        
          private boolean isEnabled(Event event) {
            return properties.getEnabledEvents().contains(event.getType());
          }
        }

________________________________________________________________________________________________________________________
#### Создание метаданных конфигурации, удобных в IDE

С eventstarter.enabled и eventstarter.listener.enabled-events мы указали два параметра конфигурации для нашего стартера.
Было бы неплохо, если бы эти параметры заполнялись автоматически, когда разработчик начинает вводить event... в файл
конфигурации.

Spring Boot предоставляет обработчик аннотаций, который собирает метаданные о параметрах конфигурации из всех
@ConfigurationProperties найденных классов. Мы просто включаем его в наш build.gradle файл:

        dependencies {
          ...
          annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
        }

Этот обработчик аннотаций сгенерирует файл META-INF/spring-configuration-metadata.json, содержащий метаданные о
параметрах конфигурации в нашем классе EventListenerProperties. Эти метаданные включают в себя Javadoc в полях,
поэтому обязательно сделайте Javadoc максимально понятным.

В IntelliJ (https://plugins.jetbrains.com/plugin/10229-spring-assistant) плагин Spring Assistant будет читать эти
метаданные и обеспечивать автозаполнение для этих свойств. Однако, это все равно оставляет eventstarter.enabled
свойство, поскольку оно не указано в @ConfigurationProperties классе.

Мы можем добавить это свойство вручную, создав файл META-INF/additional-spring-configuration-metadata.json:

        {
          "properties": [
            {
              "name": "eventstarter.enabled",
              "type": "java.lang.Boolean",
              "description": "Enables or disables the EventStarter completely."
            }
          ]
        }

Затем процессор аннотаций автоматически объединит содержимое этого файла с автоматически сгенерированным файлом, который
смогут использовать инструменты IDE. Формат этого файла описан в [справочном руководстве](https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html).

________________________________________________________________________________________________________________________
#### Улучшение времени запуска

Для каждого класса авто-конфигурации в пути к классам Spring Boot должен оценить условия, закодированные в
аннотациях @Conditional...аннотациях, чтобы решить, загружать ли авто-конфигурацию и все необходимые ему классы.
В зависимости от размера и количества стартеров в приложении Spring Boot это может оказаться очень дорогостоящей
операцией и повлиять на время запуска.

Существует еще один процессор аннотаций, который генерирует метаданные об условиях всех авто-конфигураций.
Spring Boot считывает эти метаданные во время запуска и может отфильтровывать конфигурации, условия которых не
выполняются, без необходимости фактической проверки этих классов.

Чтобы сгенерировать эти метаданные, нам просто нужно добавить обработчик аннотаций в наш стартовый модуль:

        dependencies {
            ...
            annotationProcessor 'org.springframework.boot:spring-boot-autoconfigure-processor'
        }

Во время сборки метаданные будут сгенерированы в META-INF/spring-autoconfigure-metadata.properties файл, который будет
выглядеть примерно так:

        io.reflectoring.starter.EventAutoConfiguration=
        io.reflectoring.starter.EventAutoConfiguration.ConditionalOnClass=io.reflectoring.KafkaConnector
        io.reflectoring.starter.EventAutoConfiguration.Configuration=

Я не уверен, почему метаданные содержат @ConditionalOnClass условие, а не само @ConditionalOnProperty условие. Если вы
знаете почему, пожалуйста, дайте мне знать в комментариях.

(Исходник данной статьи с комментариями: https://reflectoring.io/spring-boot-starter/)

________________________________________________________________________________________________________________________
#### Использование стартера

Теперь, когда стартер доработан, он готов к включению в приложение Spring Boot. Это так же просто, как добавить одну
зависимость в build.gradle файл:

        dependencies {
          ...
          implementation project(':event-starter')
        }

В приведенном выше примере стартер — это модуль в той же сборке Gradle, поэтому мы не используем полные координаты Maven
репозитория для идентификации стартера.

Теперь мы можем настроить стартер, используя параметры конфигурации, которые мы представили выше. Будем надеяться, что
наша IDE оценит созданные нами метаданные конфигурации и автоматически заполнит имена параметров.

Чтобы использовать наш стартер событий, теперь мы можем внедрить его EventPublisher в наши bean-компоненты и
использовать его для публикации событий. Кроме того, мы можем создавать bean-компоненты, которые расширяют EventListener
класс для получения событий и действий с ними.

Код приложения на GitHub - https://github.com/thombergs/code-examples/tree/master/spring-boot/starter/application

________________________________________________________________________________________________________________________
#### Заключение

Включение определенных функций в стартовую версию для использования их в любом приложении Spring Boot — это всего лишь
несколько простых шагов. Обеспечьте автоматическую конфигурацию, сделайте ее настраиваемой и дополните ее некоторыми
автоматически сгенерированными метаданными для повышения производительности и удобства использования.

________________________________________________________________________________________________________________________
Доп. материал (ENG):
- [Spring Boot Reference Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/index.html)