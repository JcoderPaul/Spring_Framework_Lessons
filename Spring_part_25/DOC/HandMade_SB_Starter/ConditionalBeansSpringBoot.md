См. исходники и дополнения (ENG): https://reflectoring.io/spring-boot-starter/
________________________________________________________________________________________________________________________
### Условные bean-ы с Spring Boot

При создании приложения Spring Boot мы иногда хотим загружать bean-компоненты или модули в контекст приложения только в
том случае, если выполняется какое-то условие. Будь то отключение некоторых bean-компонентов во время тестов или
реакция на определенное свойство в среде выполнения.

(Модули см. https://reflectoring.io/spring-boot-modules/)

Spring представил аннотацию @Conditional, которая позволяет нам определять собственные условия для применения к частям
контекста нашего приложения. Spring Boot построен на основе этого и предоставляет некоторые заранее определенные
условия, поэтому нам не нужно реализовывать их самостоятельно.

Тут мы рассмотрим некоторые варианты использования, которые объясняют, зачем нам вообще нужны условно загруженные
bean-компоненты. Затем мы посмотрим, как применять условия и какие условия предлагает Spring Boot. В завершение мы
также реализуем собственное условие.

Пример рабочего [кода на GitHub](https://github.com/thombergs/code-examples/tree/master/spring-boot/conditionals)

________________________________________________________________________________________________________________________
#### Зачем нам нужны условные бины?

Контекст приложения Spring содержит граф объектов, который составляет все компоненты, необходимые нашему приложению во
время выполнения. Аннотация Spring @Conditional позволяет нам определять условия, при которых определенный компонент
включается в этот граф объектов.

________________________________________________________________________________________________________________________
#### Почему нам нужно включать или исключать bean-компоненты при определенных условиях?

По моему опыту, наиболее распространенным случаем использования условий является то, что некоторые компоненты не
работают в тестовой среде. Им может потребоваться подключение к удаленной системе или серверу приложений, который
недоступен во время тестов. Итак, мы хотим выделить в отдельный модуль наши тесты, чтобы исключить или заменить
эти компоненты во время тестов.

Другой вариант использования — мы хотим включить или отключить определенную сквозную задачу. Представьте, что мы
построили модуль, настраивающий безопасность. Во время тестов для разработчиков мы не хотим каждый раз вводить имена
пользователей и пароли, поэтому щелкаем переключателем и отключаем весь модуль безопасности для локальных тестов.

Кроме того, мы можем захотеть загружать определенные bean-компоненты только в том случае, если доступен какой-либо
внешний ресурс, без которого они не могут работать. Например, мы хотим настроить наш регистратор Logback только в
том случае, если файл logback.xml был найден в пути к классам.

Мы увидим еще несколько вариантов использования в обсуждении ниже.

________________________________________________________________________________________________________________________
#### Объявление условных компонентов

Везде, где мы определяем bean-компонент Spring, мы можем при желании добавить условие. Только если это условие выполнено,
компонент будет добавлен в контекст приложения. Чтобы объявить условие, мы можем использовать любую из @Conditional...
аннотаций, описанных ниже.

Но сначала давайте посмотрим, как применить условие к определенному bean-компоненту Spring.

________________________________________________________________________________________________________________________
#### Условный @Bean

Если мы добавим условие к одному определению @Bean, этот компонент загружается только в том случае, если условие
выполнено:

        @Configuration
        class ConditionalBeanConfiguration {
        
          @Bean
          @Conditional... // <--
          ConditionalBean conditionalBean(){
            return new ConditionalBean();
          };
        }

________________________________________________________________________________________________________________________
#### Условный @Configuration

Если мы добавим условие в Spring @Configuration, все bean-компоненты, содержащиеся в этой конфигурации, будут загружены
только в том случае, если условие выполнено:

        @Configuration
        @Conditional... // <--
        class ConditionalConfiguration {
        
          @Bean
          Bean bean(){
            ...
          };
        
        }

________________________________________________________________________________________________________________________
#### Условный @Component

Наконец, мы можем добавить условие к любому компоненту, объявленному с помощью одной из стереотипных аннотаций
@Component, @Service, @Repository или @Controller:

        @Component
        @Conditional... // <--
        class ConditionalComponent {
        }

________________________________________________________________________________________________________________________
#### Предопределенные условия (Pre-Defined Conditions)

Spring Boot предлагает некоторые предопределенные аннотации @ConditionalOn... , которые мы можем использовать
«из коробки». Давайте посмотрим на каждый из них по очереди.

________________________________________________________________________________________________________________________
#### @ConditionalOnProperty

По моему опыту, аннотация @ConditionalOnProperty является наиболее часто используемой условной аннотацией в проектах
Spring Boot. Это позволяет загружать bean-компоненты условно в зависимости от определенного свойства среды:

        @Configuration
        @ConditionalOnProperty(
            value="module.enabled",
            havingValue = "true",
            matchIfMissing = true)
        class CrossCuttingConcernModule {
          ...
        }

Загружается CrossCuttingConcernModule только в том случае, если module.enabled свойство имеет значение true.
Если свойство вообще не установлено, оно все равно будет загружено, поскольку мы определили его matchIfMissing как true.
Таким образом, мы создали модуль, который загружается по умолчанию, пока мы не решим иначе.

Таким же образом мы могли бы создать другие модули для сквозных задач, таких как безопасность или планирование, которые
мы можем захотеть отключить в определенной (тестовой) среде.

________________________________________________________________________________________________________________________
#### @ConditionalOnExpression

Если у нас есть более сложное условие, основанное на нескольких свойствах, мы можем использовать
@ConditionalOnExpression:

        @Configuration
        @ConditionalOnExpression("${module.enabled:true} and ${module.submodule.enabled:true}")
        class SubModule {
          ...
        }

Загружается SubModule только в том случае, если оба свойства module.enabled и module.submodule.enabled имеют значение -
true. Добавляя ':true' к свойствам, мы указываем Spring использовать их true в качестве значения по умолчанию в случае,
если свойства не были установлены. Мы можем использовать все возможности языка выражений Spring.

(См. SpEL - https://docs.spring.io/spring-framework/reference/core/expressions.html)

Таким образом, мы можем, например, создать подмодули, которые должны быть отключены, если родительский модуль отключен,
но также могут быть отключены, если родительский модуль включен.

________________________________________________________________________________________________________________________
#### @ConditionalOnBean

Иногда нам может потребоваться загрузить компонент только в том случае, если в контексте приложения доступен
определенный другой компонент:

        @Configuration
        @ConditionalOnBean(OtherModule.class)
        class DependantModule {
          ...
        }

Загружается только в том случае, если в контексте приложения DependantModule существует компонент класса OtherModule.
Мы также могли бы определить имя компонента вместо класса компонента.

Таким образом, мы можем, например, определить зависимости между определенными модулями. Один модуль загружается только
в том случае, если доступен определенный компонент другого модуля.

________________________________________________________________________________________________________________________
#### @ConditionalOnMissingBean

Точно так же мы можем использовать, @ConditionalOnMissingBean если хотим загрузить компонент, только если определенный
другой компонент не находится в контексте приложения:

        @Configuration
        class OnMissingBeanModule {
        
          @Bean
          @ConditionalOnMissingBean
          DataSource dataSource() {
            return new InMemoryDataSource();
          }
        }

В этом примере мы внедряем источник данных, находящийся в памяти, в контекст приложения только в том случае, если
доступного источника данных еще нет. Это очень похоже на то, что Spring Boot делает внутри себя, предоставляя базу
данных в памяти (inMemory) в тестовом контексте.

________________________________________________________________________________________________________________________
#### @ConditionalOnResource

Если мы хотим загрузить компонент в зависимости от того, что определенный ресурс доступен на пути к классу, мы можем
использовать @ConditionalOnResource:

        @Configuration
        @ConditionalOnResource(resources = "/logback.xml")
        class LogbackModule {
          ...
        }

Загружается LogbackModule только в том случае, если файл конфигурации журнала был найден в пути к классам. Таким
образом, мы можем создавать аналогичные модули, которые загружаются только в том случае, если найден соответствующий
файл конфигурации.

________________________________________________________________________________________________________________________
#### Другие условия

Описанные выше условные аннотации являются наиболее распространенными, которые мы можем использовать в любом приложении
Spring Boot. Spring Boot предоставляет еще больше условных аннотаций. Однако они не так распространены, и некоторые из
них больше подходят для разработки фреймворков, а не для разработки приложений (Spring Boot активно использует некоторые
из них).

Итак, давайте лишь кратко рассмотрим их здесь.

________________________________________________________________________________________________________________________
#### @ConditionalOnClass

Загружайте компонент только в том случае, если определенный класс находится в пути к классам:

        @Configuration
        @ConditionalOnClass(name = "this.clazz.does.not.Exist")
        class OnClassModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnMissingClass

Загружайте bean-компонент только в том случае, если определенный класс отсутствует в пути к классам:

        @Configuration
        @ConditionalOnMissingClass(value = "this.clazz.does.not.Exist")
        class OnMissingClassModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnJndi

Загружайте компонент только в том случае, если определенный ресурс доступен через JNDI:

        @Configuration
        @ConditionalOnJndi("java:comp/env/foo")
        class OnJndiModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnJava

Загружайте bean-компонент только при использовании определенной версии Java:

        @Configuration
        @ConditionalOnJava(JavaVersion.EIGHT)
        class OnJavaModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnSingleCandidate

Аналогично @ConditionalOnBean, но загружает компонент только в том случае, если был определен единственный кандидат
для данного класса компонента. Вероятно, нет варианта использования за пределами авто-конфигурации:

        @Configuration
        @ConditionalOnSingleCandidate(DataSource.class)
        class OnSingleCandidateModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnWebApplication

Загружайте bean-компонент только в том случае, если мы работаем внутри веб-приложения:

        @Configuration
        @ConditionalOnWebApplication
        class OnWebApplicationModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnNotWebApplication

Загружайте bean-компонент только в том случае, если мы не запускаем его внутри веб-приложения:

        @Configuration
        @ConditionalOnNotWebApplication
        class OnNotWebApplicationModule {
          ...
        }

________________________________________________________________________________________________________________________
#### @ConditionalOnCloudPlatform

Загружайте bean-компонент только в том случае, если мы работаем на определенной облачной платформе:

        @Configuration
        @ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
        class OnCloudPlatformModule {
          ...
        }

________________________________________________________________________________________________________________________
#### Пользовательские условия

Помимо условных аннотаций, мы можем создавать свои собственные и комбинировать несколько условий с логическими
операторами.

________________________________________________________________________________________________________________________
#### Определение пользовательского условия

Представьте, что у нас есть некоторые компоненты Spring, которые естественным образом взаимодействуют с операционной
системой. Эти bean-компоненты следует загружать только в том случае, если мы запускаем приложение в соответствующей
операционной системе.

Давайте реализуем условие, которое загружает bean-компоненты только в том случае, если мы запускаем код на машине unix.
Для этого мы реализуем интерфейс [Spring Condition](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Condition.html):

        class OnUnixCondition implements Condition {
        
          @Override
            public boolean matches(
                ConditionContext context,
                AnnotatedTypeMetadata metadata) {
              return SystemUtils.IS_OS_LINUX;
            }
        }

Мы просто используем класс Apache Commons SystemUtils, чтобы определить, работаем ли мы в unix-подобной системе. При
необходимости мы могли бы включить более сложную логику, которая использует информацию о текущем контексте приложения
(ConditionContext) или об аннотированном классе (AnnotatedTypeMetadata).

Теперь условие готово к использованию в сочетании с аннотацией @Conditional Spring:

        @Bean
        @Conditional(OnUnixCondition.class)
        UnixBean unixBean() {
          return new UnixBean();
        }

________________________________________________________________________________________________________________________
#### Объединение условий с OR

Если мы хотим объединить несколько условий в одно с помощью логического оператора «ИЛИ», мы можем расширить
AnyNestedCondition:

        class OnWindowsOrUnixCondition extends AnyNestedCondition {
        
          OnWindowsOrUnixCondition() {
            super(ConfigurationPhase.REGISTER_BEAN);
          }
        
          @Conditional(OnWindowsCondition.class)
          static class OnWindows {}
        
          @Conditional(OnUnixCondition.class)
          static class OnUnix {}
        
        }

Здесь мы создали условие, которое выполняется, если приложение работает в Windows или Unix. Родительский класс
AnyNestedCondition оценит аннотации @Conditional к методам и объединит их с помощью оператора OR. Мы можем использовать
это условие так же, как и любое другое условие:

        @Bean
        @Conditional(OnWindowsOrUnixCondition.class)
        WindowsOrUnixBean windowsOrUnixBean() {
          return new WindowsOrUnixBean();
        }

________________________________________________________________________________________________________________________
#### У тебя не работает AnyNestedCondition или AllNestedConditions?

Проверьте параметр ConfigurationPhase, переданный в super(). Если вы хотите применить комбинированное условие к
компонентам @Configuration, используйте значение PARSE_CONFIGURATION. Если вы хотите применить условие к простым
компонентам, используйте, REGISTER_BEAN как показано в примере выше. Spring Boot необходимо учитывать это различие,
чтобы он мог применять условия в нужный момент во время запуска контекста приложения.

________________________________________________________________________________________________________________________
#### Объединение условий с помощью AND

Если мы хотим объединить условия с помощью логики «И», мы можем просто использовать несколько @Conditional...аннотаций
для одного компонента. Они будут автоматически объединены логическим оператором «И», так что если хотя бы одно условие
не выполнено, bean не будет загружен:

        @Bean
        @ConditionalOnUnix
        @Conditional(OnWindowsCondition.class)
        WindowsAndUnixBean windowsAndUnixBean() {
          return new WindowsAndUnixBean();
        }

Этот компонент никогда не должен загружаться, если только кто-то не создал гибрид Windows/Unix, о котором я не знаю.

Обратите внимание, что @Conditional аннотацию нельзя использовать более одного раза для одного метода или класса. Итак,
если мы хотим объединить несколько аннотаций таким образом, нам придется использовать пользовательские @ConditionalOn...
аннотации, которые не имеют этого ограничения. Ниже мы рассмотрим, как создать @ConditionalOnUnix аннотацию.

В качестве альтернативы, если мы хотим объединить условия с помощью AND в одну @Conditional аннотацию, мы можем
расширить класс Spring Boot AllNestedConditions, который работает точно так же, как AnyNestedConditions описано
выше.

________________________________________________________________________________________________________________________
#### Объединение условий с NOT

Подобно AnyNestedCondition и AllNestedConditions, мы можем расширить NoneNestedCondition загрузку компонентов только в
том случае, если НИ ОДНО из комбинированных условий не соответствует.

________________________________________________________________________________________________________________________
#### Определение пользовательской аннотации @ConditionalOn…

Мы можем создать собственную аннотацию для любого состояния. Нам просто нужно мета-аннотировать эту аннотацию с помощью
@Conditional:

        @Target({ ElementType.TYPE, ElementType.METHOD })
        @Retention(RetentionPolicy.RUNTIME)
        @Documented
        @Conditional(OnLinuxCondition.class)
        public @interface ConditionalOnUnix {
        }

Spring оценит эту мета-аннотацию, когда мы аннотируем компонент нашей новой аннотацией:

        @Bean
        @ConditionalOnUnix
        LinuxBean linuxBean(){
          return new LinuxBean();
        }

________________________________________________________________________________________________________________________
#### Заключение

Благодаря @Conditional аннотациям и возможности создания пользовательских @Conditional... аннотаций Spring уже дает нам
большие возможности для управления содержимым контекста нашего приложения.

Spring Boot опирается на это, добавляя в таблицу несколько удобных аннотаций @ConditionalOn... и позволяя нам
комбинировать условия с помощью AllNestedConditions, AnyNestedCondition или NoneNestedCondition. Эти инструменты
позволяют нам модульизировать наш производственный код, а также наши тесты.

Однако, "C мощностью приходит и ответственность", поэтому нам следует позаботиться о том, чтобы не засорять контекст нашего
приложения условиями, чтобы не потерять представление о том, что и когда загружается.

Код на github - https://github.com/thombergs/code-examples/tree/master/spring-boot/conditionals
________________________________________________________________________________________________________________________