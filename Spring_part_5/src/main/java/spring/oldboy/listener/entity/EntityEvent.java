package spring.oldboy.listener.entity;

/*
Создадим сущность, которая будет прослушиваться. События или изменения, которой
будут фиксироваться слушателем. Слушатель же сможет подписаться или отписаться от
прослушивания событий этой сущности.

Еще раз:
- есть некий объект подверженный изменениям, и он транслирует эти изменения
во вне (некий 'транслирующий канал');
- есть другой объект - слушатель - который прослушивает 'эфир'. Но не весь, а
только 'те каналы' на которые 'подписан'. И от которых он может отписаться и
не прослушивать при определенных условиях.
*/
import java.util.EventObject;

/*
Для того чтобы наш Event подключился к системе слушателей
Spring-а он должен наследовать от EventObject, либо от
класса ApplicationEvent.
*/
public class EntityEvent extends EventObject {

    /* Наш Event обладает полями и методами */
    private final AccessType accessType;

    /*
    Объектом 'СОБЫТИЯ' (event-a) будет некая сущность, т.е. событие обычно происходит с чем-то или кем-то,
    это некое изменение состояния или обращение к сущности (без внесения изменений) и т.п., другими словами,
    если с наблюдаемой сущностью ничего не произошло, то и 'СОБЫТИЯ' не было. Поэтому в конструктор передается
    сущность с которой произошло 'СОБЫТИЕ', ну и в нашем случае само событие (или AccessType).
    */
    public EntityEvent(Object entity, AccessType accessType) {
        super(entity);
        this.accessType = accessType;
    }

    /* Геттер позволяет получить 'СОБЫТИЕ' или 'название события' произошедшего с 'Event Object-ом' */
    public AccessType getAccessType() {
        return accessType;
    }
}
