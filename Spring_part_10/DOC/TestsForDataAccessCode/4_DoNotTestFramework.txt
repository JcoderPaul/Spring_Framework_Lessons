Исходник всего материала (ENG):
https://www.petrikainulainen.net/programming/testing/writing-tests-for-data-access-code-dont-test-the-framework/

См. настройка Spring проекта: https://start.spring.io/
------------------------------------------------------------------------------------------------------------------------
****** Writing Tests for Data Access Code - Don't Test the Framework ******
                  *** Не надо тестировать фреймворк ***

Когда мы пишем тесты для нашего кода доступа к данным, должны ли мы тестировать каждый метод его публичного API?
На первый взгляд это звучит естественно. В конце концов, если мы не тестируем все, как мы можем знать, что наш
код работает так, как ожидалось?

Этот вопрос дает нам важную подсказку: Сам наш код! Нам следует писать тесты только для нашего собственного кода!

------------------------------------------------------------------------------------------------------------------------
*** Что такое наш собственный код? ***

Иногда бывает трудно определить код, который нам следует протестировать. Причина этого в том, что наш код доступа к
данным тесно интегрирован с библиотекой или платформой, которую мы используем, когда сохраняем информацию в
используемое хранилище данных или считываем информацию из него.

Например, если мы хотим создать JPA-репозиторий Spring Data, который предоставляет операции CRUD для объектов Todo,
нам следует создать интерфейс, расширяющий интерфейс CrudRepository. Исходный код интерфейса TodoRepository выглядит
следующим образом:

************************************************************************************************************************
import org.springframework.data.repository.CrudRepository;

public TodoRepository extends CrudRepository<Todo, Long> {

}
************************************************************************************************************************

Несмотря на то, что мы не добавили никаких методов в интерфейс нашего репозитория, интерфейс CrudRepository объявляет
множество методов, доступных классам, использующим наш интерфейс репозитория. Эти методы не являются нашим кодом,
поскольку они реализованы и поддерживаются командой Spring Data. Мы только используем только их.

С другой стороны, если мы добавим в наш репозиторий собственный метод запроса, ситуация изменится. Давайте предположим,
что нам нужно найти все записи задач, заголовок которых равен заданному поисковому запросу. После того, как мы добавили
этот метод запроса в интерфейс нашего репозитория, его исходный код выглядит следующим образом:

************************************************************************************************************************
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

public TodoRepository extends CrudRepository<Todo, Long> {

    @Query("SELECT t FROM Todo t where t.title=:searchTerm")
    public List<Todo> search(@Param("searchTerm") String searchTerm)
}
************************************************************************************************************************

Было бы легко заявить, что этот метод — это наш собственный код и поэтому мы должны его протестировать. Однако правда
немного сложнее. Несмотря на то, что запрос JPQL был написан нами, Spring Data JPA предоставляет код, который передает
этот запрос используемому поставщику JPA.

И все же я думаю, что этот метод запроса — это наш собственный код, потому что самая существенная его часть была
написана нами.

Если мы хотим идентифицировать наш собственный код доступа к данным, нам нужно найти существенную часть каждого метода.
Если эта часть была написана нами, мы должны относиться к этому методу как к нашему собственному коду.

Это очевидно, но есть более интересный вопрос: Должны ли мы это протестировать?

Наш интерфейс репозитория предоставляет два типа методов для классов, которые его используют:
- Он предоставляет методы, объявленные интерфейсом CrudRepository.
- Он предоставляет метод запроса, который был написан нами.

Должны ли мы написать интеграционные тесты для интерфейса TodoRepository и протестировать все эти методы?

НЕТ! Нам не следует этого делать, потому что:
- Методы, объявленные интерфейсом CrudRepository, не являются нашим собственным кодом. Этот код написан и поддерживается
  командой Spring Data, и они гарантируют его работу. Если мы не верим, что их код работает, нам не следует его
  использовать.
- Наше приложение, вероятно, имеет множество интерфейсов репозитория, которые расширяют интерфейс CrudRepository. Если
  мы решим написать тесты для методов, объявленных интерфейсом CrudRepository, нам придется написать эти тесты для всех
  репозиториев. Если мы выберем этот путь, мы потратим много времени на написание тестов для чужого кода, и, честно
  говоря, оно того не стоит.
- Наш собственный код может быть настолько простым, что писать тесты для нашего репозитория не имеет смысла.

Другими словами, нам следует сконцентрироваться на поиске ответа на вопрос: Должны ли мы писать интеграционные тесты
для методов нашего репозитория (методов, которые были написаны нами) или нам следует просто писать сквозные тесты?

Ответ на этот вопрос зависит от сложности нашего метода репозитория. Я понимаю, что сложность — довольно расплывчатое
слово, и именно поэтому нам нужно какое-то руководство, которое поможет нам найти лучший способ тестирования методов
нашего репозитория.

Один из способов принять такое решение — подумать об объеме работы, необходимой для проверки всех возможных сценариев.
Это имеет смысл, потому что:
- Написание интеграционных тестов для одного метода репозитория требует меньше усилий, чем написание тех же тестов для
  функции, использующей метод репозитория.
- В любом случае нам придется писать сквозные тесты.

------------------------------------------------------------------------------------------------------------------------
Таким образом, имеет смысл минимизировать наши инвестиции (время) и максимизировать нашу прибыль (тестовое покрытие).

Конечно, это легче сказать, чем сделать, потому что каждая ситуация уникальна, и невозможно определить правила, которые
были бы действительны в каждой ситуации. Для начала мы можем найти ответы на следующие вопросы:
- Является ли функция, использующая наш метод репозитория, простой или сложной?

Мы можем получить некоторое представление об этом, задав дополнительные вопросы:
- Возвращает ли эта функция только информацию, полученную из хранилища данных, или она ее изменяет?
- Сколько зависимостей имеет эта функция?
- Сколько тестов нам нужно написать для нашей функции, если мы хотим протестировать все возможные сценарии?
- Сколько тестов нам нужно написать для нашего метода репозитория, если мы хотим протестировать все возможные сценарии?

Найдя ответы на эти вопросы, мы сможем максимизировать возврат инвестиций, следуя этим правилам:
- Если мы можем протестировать все возможные сценарии, написав всего несколько сквозных тестов, нам не следует тратить
  время на написание интеграционных тестов для нашего метода репозитория. Мы должны написать сквозные тесты, которые
  гарантируют, что функция работает должным образом.
- Если нам нужно написать больше, чем несколько тестов для нашего метода репозитория, нам следует написать
  интеграционные тесты для нашего метода репозитория и написать только несколько сквозных тестов (дымовых тестов).

Краткое содержание:
- Нам не следует тратить время на написание тестов для фреймворка доступа к данным (или библиотеки), написанной
  кем-то другим. Если мы не доверяем этой структуре (или библиотеке), нам не следует ее использовать.
- Иногда нам также не следует писать интеграционные тесты для нашего кода доступа к данным. Если тестируемый код
  достаточно прост (мы можем охватить все ситуации, написав несколько сквозных тестов), нам следует протестировать
  его, написав сквозные тесты.