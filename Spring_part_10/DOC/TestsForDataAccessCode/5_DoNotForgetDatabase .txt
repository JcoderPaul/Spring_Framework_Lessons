Исходник всего материала (ENG):
https://www.petrikainulainen.net/programming/testing/writing-tests-for-data-access-code-dont-forget-the-database/

См. настройка Spring проекта: https://start.spring.io/
------------------------------------------------------------------------------------------------------------------------
****** Writing Tests for Data Access Code - Don't Forget the Database ******
                    *** Не забывайте о базе данных ***

Когда мы пишем тесты для нашего кода доступа к данным, мы должны следовать этим трем правилам:
- Наши тесты должны использовать реальную схему базы данных.
- Наши тесты должны быть детерминированными.
- Наши тесты должны подтверждать правильные вещи.

Эти правила очевидны. Удивительно, что некоторые разработчики их нарушают (я не исключение в начале карьеры).

------------------------------------------------------------------------------------------------------------------------
*** Правило 1: Мы должны использовать реальную схему базы данных ***

Мы должны настраивать наши интеграционные тесты, используя ту же конфигурацию, которая используется нашим приложением.
Можно нарушать это правило, только если у нас есть для этого веская причина. Давайте рассмотрим одну довольно
распространенную ситуацию, когда наши интеграционные тесты используют конфигурацию, отличную от конфигурации нашего
приложения.

Мы можем создать нашу базу данных, следуя такому подходу:
- Мы создаем базу данных нашего приложения с помощью Liquibase. Мы используем интеграцию Spring для внесения необходимых
  изменений в базу данных при запуске приложения.
- Мы позволяем Hibernate создать базу данных, используемую в наших интеграционных тестах.

Я тоже так сделал, и это показалось мне идеальным решением, потому что:
- Я мог бы воспользоваться преимуществами версионной базы данных.
- Написание интеграционных тестов было похоже на прогулку по парку, потому что я мог быть уверен, что Hibernate создаст
  рабочую базу данных для моих интеграционных тестов.

Однако вскоре, я понял, что у этого подхода есть (как минимум) три проблемы:
- Если база данных создана с помощью Hibernate, мы не можем проверить, что наши сценарии миграции создают рабочую базу
  данных.
- База данных, созданная Hibernate, необязательно равна базе данных, созданной нашими сценариями миграции. Например,
  если в базе данных есть таблицы, которые не описаны как сущности, Hibernate (естественно) не создает эти таблицы.
- Если мы хотим запустить тесты производительности в наборе интеграционных тестов, мы должны настроить необходимые
  индексы с помощью аннотации @Index. Если мы этого не сделаем, Hibernate не создаст эти индексы. Это означает, что
  мы не можем доверять результатам наших тестов производительности.

Должны ли мы заботиться об этих проблемах? Определенно!

Мы должны помнить, что каждое конкретное изменение теста создает разницу между нашей тестовой конфигурацией и
производственной конфигурацией. Если эта разница слишком велика, наши тесты бесполезны.

Если мы не проведем наши интеграционные тесты для той же схемы базы данных, которая используется при развертывании
приложения в среде разработки/тестирования/производства, мы столкнемся со следующими проблемами:
- Мы не можем обязательно писать интеграционные тесты для определенных функций, поскольку в нашей базе данных
  отсутствуют необходимые таблицы, триггеры, ограничения или индексы. Это означает, что мы должны протестировать
  эти функции вручную, прежде чем приложение будет развернуто в производственной среде. Это пустая трата времени.
- Цикл обратной связи намного длиннее, чем мог бы быть, поскольку мы замечаем некоторые проблемы (например, проблемы,
  вызванные ошибочными сценариями миграции) после развертывания приложения в целевой среде.
- Если мы замечаем проблему при развертывании приложения в производственной среде - дерьмо летит на вентилятор, и мы
  накрываемся им. Я не люблю быть покрытым говном. А вы?
- Если мы хотим избежать этих проблем и максимизировать преимущества наших тестов доступа к данным, наши интеграционные
  тесты должны использовать ту же схему базы данных, которая используется при развертывании нашего приложения в
  производственной среде.

------------------------------------------------------------------------------------------------------------------------
*** Правило 2: Наши тесты должны быть детерминированными ***

Мартин Фаулер определяет недетерминированный тест следующим образом:
- Тест является недетерминированным, если он иногда проходит успешно, а иногда не проходит без каких-либо заметных
  изменений в коде, тестах или среде. Такие тесты терпят неудачу, затем вы запускаете их повторно, и они проходят.
  Провалы таких тестов кажутся случайными.

Он также объясняет, почему недетерминированные тесты являются проблемой:
- Проблема с недетерминированными тестами заключается в том, что когда они становятся красными, вы понятия не имеете,
  связано ли это с ошибкой или просто частью недетерминированного поведения. Обычно в этих тестах относительно часто
  встречаются недетерминированные сбои, поэтому в конечном итоге вы пожимаете плечами, когда эти тесты становятся
  красными. Как только вы начнете игнорировать провал регрессионного теста, этот тест станет бесполезным, и вы можете
  его выбросить.

Нам должно быть ясно, что недетерминированные тесты вредны, и нам следует избегать их любой ценой.

Итак, какова наиболее распространенная причина недетерминированных тестов доступа к данным?

Мой опыт научил меня, что наиболее распространенной причиной недетерминированных тестов доступа к данным является
неспособность инициализировать базу данных в известном состоянии перед запуском каждого тестового примера.

Это печально, потому что эту проблему действительно легко решить. Фактически, мы можем решить эту проблему, используя
один из этих вариантов:
- Мы можем добавлять информацию в базу данных, используя другие методы тестируемого репозитория.
- Мы можем написать библиотеку, которая инициализирует нашу базу данных перед запуском каждого теста.
- Мы можем использовать существующие библиотеки, такие как DbUnit и NoSQLUnit.

Однако надо быть осторожным, поскольку только эти варианты имеют смысл только если:
- Первый вариант – худший способ решения этой проблемы. Это загромождает наши методы тестирования ненужным кодом
                   инициализации и делает их очень хрупкими. Например, если мы сломаем метод, используемый для
                   сохранения информации в нашей базе данных, каждый тест, который его использует, завершится
                   неудачей.
- Второй вариант - немного лучше. Однако зачем нам создавать новую библиотеку, если мы можем использовать уже
                   существующую, которая доказала свою эффективность? Нам не следует изобретать велосипед. Мы должны
                   решить эту проблему самым простым и лучшим способом. Мы должны использовать существующую библиотеку.

------------------------------------------------------------------------------------------------------------------------
*** Правило 3: Мы должны утверждать правильные вещи ***

Когда мы пишем тесты для нашего кода доступа к данным, нам, возможно, придется написать тесты, которые:
- прочитают информацию из базы данных;
- запишут информацию в базу данных;

Какие утверждения нам нужно написать?

- ВО-ПЕРВЫХ, если тесты записи считывают информацию из базы данных, мы должны следовать следующим правилам:
    - Если мы используем структуру или библиотеку (например, Spring Data), которая сопоставляет информацию, взятую
      из базы данных, с объектами, нет смысла утверждать, что каждое значение свойства возвращаемого объекта является
      правильным. В этой ситуации мы должны убедиться, что значение свойства, идентифицирующего возвращаемый объект,
      правильное. Причина этого в том, что мы должны использовать только те фреймворки или библиотеки, которым мы
      доверяем. Если мы уверены, что наша платформа доступа к данным или библиотека выполняют свою работу, нет смысла
      утверждать все.
    - Если мы реализовали репозиторий, который сопоставляет информацию, взятую из базы данных, с объектами, мы должны
      убедиться, что каждое значение свойства возвращаемого объекта является правильным. Если мы этого не сделаем, мы
      не сможем быть уверены, что наш репозиторий работает корректно.

- ВО-ВТОРЫХ, если мы пишем тесты, которые записывают информацию в базу данных, нам не следует добавлять какие-либо
             утверждения в наш метод тестирования.

Мы должны использовать такой инструмент, как DbUnit или NoSQLUnit, чтобы гарантировать сохранение правильной информации
в базе данных. Этот подход имеет два преимущества:
- Мы можем написать наши утверждения на нужном уровне. Другими словами, мы можем убедиться, что информация действительно
  сохранена в используемой базе данных.
- Мы можем избежать загромождения наших методов тестирования кодом, который находит сохраненную информацию в используемой
  базе данных и проверяет, найдена ли правильная информация.

Но что, если мы хотим гарантировать, что метод, сохраняющий информацию в базу данных, возвращает правильную информацию?
Что ж, если мы реализовали этот метод самостоятельно, нам придется написать для этого метода два теста:
- Мы должны гарантировать, что в базе данных хранится правильная информация.
- Мы должны убедиться, что метод возвращает правильную информацию.

С другой стороны, если этот метод нам предоставляет фреймворк или библиотека, нам не следует писать для него какие-либо
тесты.

Мы должны помнить, что наша цель — не писать утверждения, гарантирующие правильную работу используемой платформы или
библиотеки доступа к данным.

Наша цель — написать утверждения, которые гарантируют правильную работу нашего кода.

Краткое содержание:
- Если мы хотим максимизировать преимущества наших тестов доступа к данным, наши интеграционные тесты должны
  использовать ту же схему базы данных, которая используется при развертывании нашего приложения в производственной
  среде.
- Избавиться от недетерминированных тестов легко. Все, что нам нужно сделать, это инициализировать нашу базу данных
  в известном состоянии перед запуском каждого тестового примера с использованием такой библиотеки, как DbUnit или
  NoSQLUnit.
- Если нам нужно убедиться, что в используемой базе данных сохранена правильная информация, мы должны использовать
  такую библиотеку, как DbUnit или NoSQLUnit.
- Если мы хотим убедиться, что из используемой базы данных возвращается правильная информация, мы должны написать
  утверждения (assertions), гарантирующие работу нашего кода.