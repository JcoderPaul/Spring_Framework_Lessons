Исходник всего материала (ENG):
https://www.petrikainulainen.net/programming/testing/writing-tests-for-data-access-code-data-matters/

См. настройка Spring проекта: https://start.spring.io/
------------------------------------------------------------------------------------------------------------------------
****** Writing Tests for Data Access Code - Data Matters ******
                *** Данные имеют значение ***

Когда мы пишем тесты для нашего кода доступа к данным, мы используем наборы данных для двух разных целей:
- Мы инициализируем нашу базу данных в известном состоянии перед запуском тестов доступа к данным.
- Мы проверяем, что правильные изменения найдены в базе данных.

Вроде легко. Однако, так же легко все испортить так, что это отнимет много времени. В этой статье описаны три наиболее
распространенные ошибки, которые мы можем допустить при использовании наборов данных DbUnit, и, что более важно, как
можно их избежать.

------------------------------------------------------------------------------------------------------------------------
*** Три смертных греха наборов данных DbUnit ***

Самая распространенная причина, по которой такие библиотеки, как DbUnit, имеют такую плохую репутацию, заключается в
том, что разработчики используют их неправильно и жалуются после того, как нанесли себе удар по ноге.

Это правда, что когда мы используем наборы данных DbUnit, мы можем допускать ошибки, которые вызывают большое
разочарование и отнимают у нас много времени. Вот почему мы должны понять, в чем заключаются эти ошибки, чтобы не
совершать их.

Есть три распространенные (и дорогостоящие) ошибки, которые мы можем допустить при использовании наборов данных DbUnit:

------------------------------------------------------------------------------------------------------------------------
*** 1. Инициализация базы данных с использованием одного набора данных. ***

Первая ошибка, которую мы можем допустить, это инициализировать нашу базу данных, используя один набор данных. Хотя это
очень удобно, если наше приложение имеет лишь несколько функций и небольшую базу данных с несколькими таблицами базы
данных, это может быть не так, если мы работаем над реальным программным проектом.

Скорее всего, наше приложение имеет множество функций и большую базу данных с десятками (или сотнями) таблиц базы данных.
Если мы будем использовать этот подход в реальном программном проекте, наш набор данных будет ОГРОМНЫМ, потому что:
- Каждая таблица базы данных увеличивает размер нашего набора данных.
- Количество тестов увеличивает размер нашего набора данных, поскольку разные тесты требуют разных данных.

Размер нашего набора данных является большой проблемой, потому что:
- Чем больше набор данных, тем медленнее происходит инициализация используемой базы данных до известного состояния
  перед запуском наших тестов. Что еще хуже, наши тесты становятся все медленнее и медленнее, когда мы добавляем новые
  таблицы базы данных или пишем новые тесты.
- Невозможно узнать, какие данные актуальны для конкретного тестового примера, не читая тестируемый код. Если тестовый
  пример не пройден, выяснить причину этого намного сложнее, чем следовало бы.

Пример: Предположим, нам нужно написать тесты для CRM, которая используется для управления информацией наших клиентов
        и офисов. При этом каждый клиент и офис находится в городе. Первая версия нашего набора данных может выглядеть
        следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>

    <customers id="1" city_id="1" name="Company A"/>

    <offices id="1" city_id="1" name="Office A"/>
</dataset>
************************************************************************************************************************

Мы сразу видим, что наш набор тестов должен вызывать один ненужный оператор INSERT для каждого тестового примера. Это
может показаться не таким уж большим делом, но давайте посмотрим, что произойдет, когда нам придется написать тесты для
функций, в которых перечислены клиенты и офисы, расположенные в определенном городе.

После того, как мы написали эти тесты, наш набор данных выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>
    <cities id="3" name="Turku"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>

    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="3" name="Office B"/>
</dataset>
************************************************************************************************************************

Как мы можем видеть:
- Наш набор тестов должен вызывать три ненужных оператора INSERT для каждого тестового примера.
- Неясно, какие данные актуальны для конкретного тестового примера, поскольку наш набор данных инициализирует всю базу
  данных перед запуском каждого теста.

Это может показаться не катастрофическим провалом (но, это не так), зато этот пример все же демонстрирует, почему нам
не следует двигаться в этом направлении при написании тестов для реальных приложений.

------------------------------------------------------------------------------------------------------------------------
*** 2. Создание одного набора данных для каждого тестового набора или группы тестовых случаев. ***

Мы можем решить проблемы, создаваемые одним набором данных, разделив этот набор данных на более мелкие наборы данных.
Если мы решим сделать это, мы можем создать один набор данных для каждого тестового примера или групповых тестовых
случаев.

Если мы будем следовать этому подходу, каждый из наших наборов данных должен содержать только те данные, которые имеют
отношение к тестовому примеру (или тестовым примерам). Это кажется хорошей идеей, поскольку наши наборы данных меньше,
и каждый набор данных содержит только соответствующие данные.

Однако, хотя наши тесты выполняются быстрее, чем тесты, использующие один набор данных, и легко найти данные,
соответствующие конкретному тестовому примеру.

У этого подхода есть один существенный недостаток: !!! Поддержание наших наборов данных становится адом !!!

Поскольку многие наборы данных содержат данные, которые вставляются в одни и те же таблицы, обслуживание этих наборов
данных требует много работы, если структура этих таблиц базы данных изменяется (или лучше сказать, когда?).

Пример: Если мы будем использовать этот подход при написании тестов для CRM, который был представлен ранее, мы могли
        бы разделить наш один набор данных на два меньших набора данных.

Первый набор данных содержит информацию, которая требуется, когда мы пишем тесты для функций, которые используются для
управления информацией наших клиентов.

Это выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>
</dataset>
************************************************************************************************************************

Второй набор данных содержит информацию, которая нам нужна, когда мы пишем тесты для функций, которые используются для
управления информацией наших офисов.

Второй набор данных выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="3" name="Turku"/>

    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="3" name="Office B"/>
</dataset>
************************************************************************************************************************

Что произойдет, если мы внесем изменения в структуру таблицы городов? Точно! Вот почему следовать этому подходу – не
лучшая идея.

------------------------------------------------------------------------------------------------------------------------
*** 3. Утверждение всего - Asserting Everything ***

Мы можем создать набор данных, который будет использоваться для проверки того, что в базе данных найдены правильные
данные, выполнив следующие шаги:
- Шаг 1. - Скопируем данные, найденные из набора данных, который используется для инициализации базы данных, в известное
           состояние перед запуском наших тестов.
- Шаг 2. - Вставим его содержимое в набор данных, который используется для проверки того, что в базе данных найдены
           правильные данные.
- Шаг 3. - Внесем в него необходимые изменения.

Следовать этим шагам опасно, потому что это не имеет смысл. В конце концов, если мы инициализировали нашу базу данных,
используя набор данных X, кажется логичным, что мы используем этот набор данных при создании набора данных, который
используется для обеспечения поиска правильной информации в базе данных.

Однако у этого подхода есть три недостатка:
- Трудно предугадать ожидаемый результат, поскольку часто эти наборы данных содержат информацию, которая не изменяется
  тестируемым кодом. Это проблема, особенно если мы допустили одну или две ошибки.
- Поскольку эти наборы данных содержат информацию, которая не изменяется тестируемым кодом (например, общие таблицы базы
  данных), обслуживание этих наборов данных потребует много ненужной работы. Если мы изменим структуру этих таблиц базы
  данных, нам придется внести такие же изменения и в наши наборы данных. Это то, чего мы не хотим делать.
- Поскольку эти наборы данных часто содержат ненужную информацию (информацию, которая не изменяется тестируемым кодом),
  проверка того, что ожидаемая информация находится в базе данных, происходит медленнее, чем могла бы быть.

Пример: Предположим, нам нужно написать тесты для функции, обновляющей информацию о клиенте (идентификатор обновленного
        клиента равен 2).

Набор данных, который инициализирует используемую базу данных в известном состоянии перед запуском этого теста, выглядит
следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>
</dataset>
************************************************************************************************************************

Набор данных, обеспечивающий сохранение правильной информации в базе данных, выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="1" name="Company B"/>
</dataset>
************************************************************************************************************************

Давайте рассмотрим недостатки этого решения один за другим:
- Определить, какую информацию следует обновить, довольно легко, поскольку размер нашего набора данных очень мал, но это
  не так просто, как могло бы быть. Если бы наш набор данных был больше, это, естественно, было бы намного сложнее.
- Этот набор данных содержит информацию, найденную из таблицы городов. Поскольку эта информация не изменяется тестируемой
  функцией, наши тесты должны делать нерелевантные утверждения, а это означает, что наши тесты работают медленнее, чем
  могли бы быть.
- Если мы изменим структуру таблицы базы данных городов, нам придется изменить набор данных, который проверяет, что
  правильная информация сохраняется в базе данных. Это означает, что обслуживание этих наборов данных занимает много
  времени и заставляет нас выполнять ненужную работу.

------------------------------------------------------------------------------------------------------------------------
*** Наборы данных сделаны правильно ***

Мы определили три наиболее распространенные ошибки, которые допускают разработчики при использовании наборов данных
DbUnit. Теперь пришло время выяснить, как мы можем избежать этих ошибок и эффективно использовать наборы данных в
наших тестах.

Давайте начнем с более подробного рассмотрения требований к хорошему набору тестов. Требования к хорошему набору
тестов:
- Должно быть легко читать - Если наш набор тестов легко читать, он действует как документация, которая всегда актуальна,
  и в случае неудачного тестового примера можно быстрее выяснить, что не так.
- Он должен быть простым в обслуживании - Набор тестов, который легко поддерживать, сэкономит нам много времени, которое
  мы сможем использовать более продуктивно. Кроме того, это, вероятно, спасет нас от многих разочарований.
- Он должен быть максимально быстрым - потому что набор быстрых тестов обеспечивает быструю обратную связь, а быстрая
  обратная связь означает, что мы можем использовать свое время более продуктивно. Кроме того, мы должны понимать, что
  хотя набор интеграционных тестов обычно работает намного медленнее, чем набор модульных тестов, отказываться от этого
  требования не имеет смысла. На самом деле я утверждаю, что нам следует уделять этому больше внимания, потому что если
  мы сделаем это, то сможем значительно сократить время выполнения нашего набора тестов.

------------------------------------------------------------------------------------------------------------------------
Вы можете задаться вопросом, почему я не упомянул, что каждый тестовый пример должен быть независимым. Это действительно
важное требование хорошего набора тестов, но я его не упомянул, потому что, если мы уже используем такой инструмент, как
DbUnit, мы, вероятно, поняли, что наши тестовые сценарии не должны зависеть от других тестовых случаев.
------------------------------------------------------------------------------------------------------------------------

Теперь, когда мы знаем, каковы требования нашего набора тестов, нам намного проще понять, как мы можем их выполнить,
используя наборы данных DbUnit.

Если мы хотим выполнить эти требования, мы должны следовать следующим правилам:

------------------------------------------------------------------------------------------------------------------------
*** 1. Используйте небольшие наборы данных ***

Мы должны использовать небольшие наборы данных, потому что их легче читать и они гарантируют максимально быструю скорость
наших тестов. Другими словами, мы должны определить минимальный объем данных, необходимый для написания наших тестов, и
использовать только эти данные.

Пример: Набор данных, который используется для инициализации нашей базы данных при тестировании функций, связанных с
        клиентом, выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/> /* ! */
    <cities id="2" name="Tampere"/> /* ! */

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>
</dataset>
************************************************************************************************************************

С другой стороны, набор данных, который инициализирует нашу базу данных, когда мы запускаем тесты, проверяющие офисные
функции, выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/> /* ! */
    <cities id="3" name="Turku"/> /* ! */

    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="3" name="Office B"/>
</dataset>
************************************************************************************************************************

Если мы посмотрим на выделенные строки, мы заметим, что в наших наборах данных используются разные города. Мы можем
исправить это, изменив второй набор данных, чтобы использовать те же города, что и первый набор данных. После того,
как мы это сделаем, второй набор данных будет выглядеть следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="2" name="Office B"/>
</dataset>
************************************************************************************************************************

Итак, в чем смысл? Казалось бы, многого мы не добились, но нам удалось сократить количество используемых городов с трёх
до двух. Причина ценности этого небольшого улучшения становится очевидной, когда мы взглянем на следующее правило.

Обычно наборы данных DbUnit большие, беспорядочные и содержат много избыточных данных. Если это так, то следование этому
подходу сделает наши наборы данных намного более читаемыми и сделает наши тесты намного быстрее.

------------------------------------------------------------------------------------------------------------------------
*** 2. Разделите большие наборы данных на более мелкие наборы данных. ***

Мы уже создали два набора данных, которые содержат минимальный объем данных, необходимый для инициализации нашей базы
данных перед запуском наших тестов. Проблема в том, что оба набора данных содержат «общие» данные, и это затрудняет
обслуживание наших наборов данных.

Мы можем избавиться от этой проблемы, выполнив следующие шаги:
- Шаг 1. - Определим данные, которые используются более чем в одном наборе данных.
- Шаг 2. - Переместим эти данные в отдельный набор данных (или в несколько наборов данных).

Пример: У нас есть два набора данных, которые выглядят следующим образом (общие данные выделены):

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>
</dataset>
************************************************************************************************************************

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="2" name="Office B"/>
</dataset>
************************************************************************************************************************

Мы можем устранить проблему с обслуживанием, создав единый набор данных, содержащий информацию, вставленную в таблицу
городов. После того, как мы это сделали, у нас есть три набора данных, которые выглядят следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>
</dataset>
************************************************************************************************************************

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="2" name="Company B"/>
</dataset>
************************************************************************************************************************

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <offices id="1" city_id="1" name="Office A"/>
    <offices id="2" city_id="2" name="Office B"/>
</dataset>
************************************************************************************************************************

Что мы только что сделали? Самое значительное улучшение заключается в том, что если мы внесем изменения в таблицу
городов, нам придется внести эти изменения только в один набор данных. Другими словами, поддерживать эти наборы
данных стало намного проще, чем раньше.

------------------------------------------------------------------------------------------------------------------------
*** 3. Проверяйте на утверждение только ту информацию (Assert Only), которая может быть изменена тестируемым кодом. ***

Ранее мы рассмотрели набор данных, который гарантировал, что правильная информация будет найдена в используемой базе
данных при обновлении информации о клиенте. Проблема в том, что набор данных содержит данные, которые не могут быть
изменены тестируемым кодом.

Это значит, что:
- Трудно определить ожидаемый результат, поскольку наш набор данных содержит нерелевантные данные.
- Наши тесты медленнее, чем могли бы быть, потому что им приходится делать нерелевантные утверждения.
- Наши тесты сложно поддерживать, потому что если мы вносим изменения в базу данных, нам приходится вносить такие же
  изменения и в наши наборы данных.

Мы можем решить каждую из этих проблем, следуя этому простому правилу:
- Мы должны утверждать только ту информацию, которая может быть изменена тестируемым кодом.

Давайте разберемся, что означает это правило.

Пример: Ранее мы создали (проблемный) набор данных, который гарантирует сохранение правильной информации в базе данных
        при обновлении информации о клиенте (идентификатор обновленного клиента равен 2). Этот набор данных выглядит
        следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <cities id="1" name="Helsinki"/>
    <cities id="2" name="Tampere"/>

    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="1" name="Company B"/>
</dataset>
************************************************************************************************************************

Мы можем решить проблемы, сохранив важные данные и удалив другие данные. Если мы пишем тест, который гарантирует, что
информация о правильном клиенте будет обновлена в базе данных, совершенно очевидно, что нас не волнует информация,
найденная в таблице городов. Единственное, что нас волнует - это данные, которые можно найти в таблице клиентов.

После того, как мы удалили ненужную информацию из нашего набора данных, он выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <customers id="1" city_id="1" name="Company A"/>
    <customers id="2" city_id="1" name="Company B"/>
</dataset>
************************************************************************************************************************

Мы по-прежнему должны утверждать значения всех столбцов, найденных в таблице клиентов. Если мы этого не сделаем, мы
можем случайно обновить значение неправильного столбца и нам это сойдет с рук. Мы исправили проблемы с
производительностью и обслуживанием, но осталась еще одна проблема:
- Наш набор данных состоит из двух строк, и неясно, какая строка содержит обновленную информацию. Это не такая уж
  большая проблема, поскольку наш набор данных довольно мал, но это может стать проблемой, когда мы используем большие
  наборы данных. Мы можем решить эту проблему, добавив комментарий к нашему набору данных.

После того, как мы это сделали, наш набор данных выглядит следующим образом:

************************************************************************************************************************
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <customers id="1" city_id="1" name="Company A"/>

    <!-- Информация об обновленном клиенте -->
    <customers id="2" city_id="1" name="Company B"/>
</dataset>
************************************************************************************************************************
Намного лучше. Верно?

Краткое содержание:
- Три наиболее распространенные ошибки, которые мы можем совершить при использовании наборов данных DbUnit, кажутся
  хорошей идеей, но если мы совершим эти ошибки в реальном программном проекте, мы выстрелим себе в ногу.
- Мы можем избежать проблем, вызванных наборами данных DbUnit, используя небольшие наборы данных, разделяя большие
  наборы данных на более мелкие и утверждая только ту информацию, которая может быть изменена тестируемым кодом.