Первичный источник: ["Projections with JPA and Hibernate" by Thorben Janssen](https://thorben-janssen.com/projections-with-jpa-and-hibernate/)

---
### Проекции с Hibernate

Выбор правильной проекции при выборе данных с помощью JPA и Hibernate невероятно важен. Когда я работаю над **повышением
производительности приложения, то всегда работаю над ускорением запросов**. По крайней мере **80% из них можно значительно
улучшить, отрегулировав проекцию или используя правильный FetchType**.

К сожалению, изменение проекции существующего запроса всегда требует значительного рефакторинга бизнес-кода. Поэтому
лучше сначала выбрать хорошую проекцию. Это относительно просто, если следовать нескольким основным правилам, которые
мы рассмотрим ниже.

Но прежде чем мы это сделаем, давайте быстро объясним:

- **Что такое проекция?**
- **Какие проекции поддерживают JPA и Hibernate?**
- **Проекции сущностей.**
- **Проекции скалярных значений.**
- **Функции базы данных в проекциях скалярных значений.**
- **Проекции DTO.**
- **Функции базы данных в проекциях DTO.**

---
#### Что такое проекция?

Проекция описывает, какие столбцы вы выбираете из своей базы данных и в какой форме Hibernate предоставляет их вам.
Другими словами, если вы пишете запрос JPQL, это все, что находится между ключевыми словами SELECT и FROM.

```Java
  em.createQuery("SELECT b.title, b.publisher, b.author.name FROM Book b");
```

---
#### Какие проекции поддерживают JPA и Hibernate?

JPA и Hibernate поддерживают **3 группы проекций**:

- **Скалярные значения**;
- **Сущности**;
- **DTO**;

SQL поддерживает только скалярные проекции, такие как столбцы таблиц или возвращаемое значение функции базы данных.

Итак, как JPA и Hibernate могут поддерживать больше проекций?

Hibernate сначала проверяет, какую информацию ему необходимо получить из базы данных, и генерирует для нее оператор
SQL с проекцией скалярного значения. Затем он выполняет запрос и возвращает результат, если вы использовали в своем
коде проекцию скалярного значения. Если вы запросили DTO или проекцию объекта, Hibernate применяет дополнительный
этап преобразования. Он перебирает набор результатов и создает экземпляр объекта или объекта DTO для каждой записи.

Давайте подробнее рассмотрим все три проекции и обсудим, когда какую из них следует использовать.

---
#### Проекции сущностей

Для большинства команд, сущности - являются наиболее распространенной проекцией. Их очень легко использовать с JPA и
Hibernate.

Вы можете использовать метод find в своем EntityManager или написать простой запрос JPQL или Criteria, который выбирает
один или несколько объектов. Spring Data JPA может даже получить запрос, который возвращает сущность из имени вашего
метода репозитория см. [6_QueriesFromMethodNames.md](../SpringDataJPATutorial/6_QueriesFromMethodNames.md).

```Java
  TypedQuery<Book> q = em.createQuery("SELECT b FROM Book b", Book.class);
  List<Book> books = q.getResultList();
```

Все объекты, которые вы загружаете из базы данных или извлекаете из одного из кешей Hibernate, находятся в управляемом
состоянии жизненного цикла. Это означает, что ваш поставщик персистентности, например Hibernate, автоматически обновит
или удалит соответствующую запись базы данных, если вы измените значение атрибута сущности или решите удалить сущность.

```Java
  b.setTitle("Hibernate Tips - More than 70 solutions to common Hibernate problems");
```

**Сущности - единственная проекция, имеющая управляемое состояние жизненного цикла.** Всякий раз, когда вы хотите реализовать
операцию записи, вам следует извлекать объекты из базы данных. Они значительно упрощают реализацию операций записи и
часто даже обеспечивают оптимизацию производительности.

Но если вы реализуете вариант использования только для чтения, вам следует предпочесть другую проекцию. Управление
состоянием жизненного цикла, обеспечение наличия только одного объекта сущности для каждой сопоставленной записи базы
данных в сеансе, а также все другие функции, предоставляемые Hibernate, создают накладные расходы. Эти издержки делают
проекцию объекта медленнее, чем скалярное значение или проекцию DTO.

---
#### Проекции скалярных значений

Проекции скалярных значений позволяют избежать накладных расходов на управление, присущих проекциям сущностей, но их не
очень удобно использовать. Hibernate не преобразует результат запроса. Таким образом, в результате вашего запроса вы
получаете Object или Object[].

```Java
  Query q = em.createQuery("SELECT b.title, b.publisher, b.author.name FROM Book b");
  List<Object[]> books = (Object[]) q.getResultList();
```

На следующем шаге вам нужно будет перебрать каждую запись в наборе результатов и привести каждый объект к определенному
типу, прежде чем вы сможете его использовать. Это делает ваш код подверженным ошибкам и трудным для чтения.

Вместо Object[] вы также можете получить скалярную проекцию в виде интерфейса Tuple см.
- [Tuple](https://github.com/JcoderPaul/Hibernate_Lessons/blob/master/Hibernate_part_5/DOC/Tuple.txt);
- [TupleInterface](https://github.com/JcoderPaul/Hibernate_Lessons/blob/master/Hibernate_part_5/DOC/TupleInterface.txt);

Интерфейс немного проще в использовании, чем Object[].

```Java
  TypedQuery<Tuple> q = em.createQuery("SELECT b.title as title,
                                               b.publisher as publisher,
                                               b.author.name as author FROM Book b", Tuple.class);
  List<Tuple> books = q.getResultList();
  
  for (Tuple b : books) {
      log.info(b.get("title"));
  }
```

Но не ожидайте слишком многого. Он предоставляет лишь несколько дополнительных методов для получения элемента, например,
по его псевдониму. Но возвращаемые значения по-прежнему имеют тип Object, и ваш код по-прежнему подвержен ошибкам, как
и при использовании Object[].

---
#### Функции базы данных в проекциях скалярных значений

Проекции скалярных значений не ограничиваются отдельными атрибутами объекта. Вы также можете включить возвращаемые
значения одной или нескольких функций базы данных.

```Java
  TypedQuery<Tuple> q = em.createQuery("SELECT AVG(b.sales) as avg_sales, SUM(b.sales) as total_sales, COUNT(b) as books, b.author.name as author FROM Book b GROUP BY b.author.name", Tuple.class);
  List<Tuple> authors = q.getResultList();
  
  for (Tuple a : authors) {
      log.info("author:" + a.get("author")
              + ", books:" + a.get("books")
              + ", AVG sales:" + a.get("avg_sales")
              + ", total sales:" + a.get("total_sales"));
  }
```

Это огромное преимущество по сравнению с проекцией сущности. Если вы использовали проекцию сущности, как в предыдущем
примере, вам нужно будет выбрать все сущности «Книга» со связанной с ними сущностью «Автор». На следующем этапе вам
нужно будет подсчитать количество книг, написанных каждым автором, и рассчитать общий и средний объем продаж.

Как вы можете видеть из фрагмента кода, использование функции базы данных проще, а также обеспечивает лучшую
производительность.

---
### Проекции DTO

**Проекции DTO — лучший вид проекций для операций только для чтения**. Hibernate создает экземпляры объектов DTO на этапе
постобработки после получения результата запроса из базы данных. Затем он перебирает набор результатов и выполняет
описанный вызов конструктора для каждой записи.

Здесь вы можете увидеть простой пример запроса JPQL, который возвращает результат запроса в виде списка объектов
BookDTO. Используя ключевое слово new и предоставляя полное имя вашего класса DTO и массив ссылок на атрибуты
сущности, вы можете определить вызов конструктора. Затем Hibernate будет использовать проекцию для вызова этого
конструктора.

```Java
  TypedQuery<BookDTO> q = em.createQuery("SELECT new org.thoughtsonjava.projection.dto.BookDTO(b.title,
                                                                                               b.author.name,
                                                                                               b.publisher)
                                          FROM Book b", BookDTO.class);
  List<BookDTO> books = q.getResultList();
```

В отличие от проекции сущности, накладные расходы проекции DTO минимальны. Объекты не являются частью текущего контекста
персистентности и не следуют никакому управляемому жизненному циклу. По этой причине Hibernate не будет генерировать
операторы SQL UPDATE, если вы измените значение атрибута DTO. Но при этом не требуется никаких затрат на управление, что
обеспечивает значительный выигрыш в производительности.

---
### Функции базы данных в проекциях DTO

Подобно проекции скалярных значений, вы также можете использовать функции базы данных в проекции DTO. Как объяснялось
ранее, создание экземпляра объекта DTO — это этап постобработки после того, как Hibernate получил результат запроса.
На этом этапе не имеет никакого значения, было ли значение сохранено в столбце базы данных или оно было вычислено
функцией базы данных. Hibernate просто получает его из набора результатов и предоставляет в качестве параметра
конструктора.

И так, **JPA и Hibernate поддерживают 3 группы проекций**:
- **Сущности - самая простая и распространенная проекция.** Они отлично **подходят, если вам нужно изменить данные**, но они
  не самые эффективные для случаев использования только для чтения.
- **Скалярные проекции возвращаются как Object[] так и экземпляры интерфейса Tuple.** Обе версии не предоставляют никакой
  информации о типе и сложны в использовании. **Несмотря на то, что они очень эффективны для операций только для чтения,
  вам следует избегать их в своем приложении.**
- **Проекции DTO - обеспечивают такую же производительность, как и проекции скалярных значений**, но их гораздо проще
  использовать. Это делает их лучшей **проекцией для операций только для чтения**.
