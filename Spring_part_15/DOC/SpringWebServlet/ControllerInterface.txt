****** Interface Controller ******
________________________________________________________________________________________________________________________
Пакет: org.springframework.web.servlet.mvc

Все реализующие классы: AbstractController,
                        AbstractUrlViewController,
                        ParameterizableViewController,
                        ServletForwardingController,
                        ServletWrappingController,
                        UrlFilenameViewController

Функциональный интерфейс: Это функциональный интерфейс, поэтому его можно использовать в качестве цели назначения для
                          лямбда-выражения или ссылки на метод.

См. так же: SimpleControllerHandlerAdapter,
            AbstractController,
            MockHttpServletRequest,
            MockHttpServletResponse,
            ApplicationContextAware,
            ResourceLoaderAware,
            ServletContextAware,
            WebApplicationObjectSupport
________________________________________________________________________________________________________________________
@FunctionalInterface
public interface Controller
________________________________________________________________________________________________________________________
Интерфейс базового контроллера, представляющий компонент, который получает экземпляры HttpServletRequest и
HttpServletResponse, как и HttpServlet, но может участвовать в рабочем процессе MVC. Контроллеры можно сравнить с
понятием действия Struts.

Любая реализация интерфейса контроллера должна представлять собой многоразовый, потокобезопасный класс, способный
обрабатывать несколько HTTP-запросов на протяжении всего жизненного цикла приложения. Чтобы иметь возможность легко
настроить контроллер, рекомендуется, чтобы реализации контроллера были (и обычно являются) JavaBeans.

-- Рабочий процесс --

После того как DispatcherServlet получил запрос и выполнил свою работу по разрешению локалей, тем и т. д., он пытается
разрешить контроллер, используя HandlerMapping. Когда будет найден контроллер для обработки запроса, будет вызван метод
handleRequest обнаруженного контроллера; затем обнаруженный контроллер отвечает за обработку фактического запроса и,
если применимо, за возврат соответствующего ModelAndView.

Фактически этот метод является основной точкой входа для DispatcherServlet, который делегирует запросы контроллерам.

Таким образом, в основном любая прямая реализация интерфейса контроллера просто обрабатывает HttpServletRequests и
должна возвращать ModelAndView для дальнейшей интерпретации DispatcherServlet. Любые дополнительные функции, такие как
необязательная проверка, обработка форм и т. д., должны быть получены путем расширения AbstractController или одного из
его подклассов.

-- Примечания по проектированию и тестированию --

Интерфейс контроллера явно предназначен для работы с объектами HttpServletRequest и HttpServletResponse, как и
HttpServlet. Он не стремится отделиться от API сервлетов, в отличии, например, от WebWork, JSF или Tapestry. Вместо
этого доступна вся мощь API сервлетов, что позволяет контроллерам быть универсальными: контроллер способен не только
обрабатывать запросы веб-интерфейса пользователя, но также обрабатывать протоколы удаленного взаимодействия или
генерировать отчеты по требованию.

Контроллеры можно легко протестировать, передав фиктивные объекты для объектов HttpServletRequest и HttpServletResponse
в качестве параметров методу handleRequest. Для удобства Spring поставляется с набором макетов API сервлетов, которые
подходят для тестирования любых веб-компонентов, но особенно подходят для тестирования веб-контроллеров Spring.

В отличие от действия Struts, нет необходимости имитировать (mock) ActionServlet или любую другую инфраструктуру;
достаточно mocking (имитации) HttpServletRequest и HttpServletResponse.

Если контроллерам необходимо знать о конкретных ссылках на среду, они могут реализовать определенные интерфейсы
осведомленности, как это может сделать любой другой компонент в контексте Spring (веб-приложения), например:
- org.springframework.context.ApplicationContextAware
- org.springframework.context.ResourceLoaderAware
- org.springframework.web.context.ServletContextAware

Такие ссылки на среду можно легко передавать в средах тестирования через соответствующие установщики, определенные в
соответствующих интерфейсах осведомленности. В общем, рекомендуется минимизировать зависимости: например, если вам нужна
только загрузка ресурсов, реализуйте только ResourceLoaderAware. В качестве альтернативы можно получить производный
класс от базового класса WebApplicationObjectSupport, который предоставляет все эти ссылки через удобные средства
доступа, но требует ссылку на ApplicationContext при инициализации.

Контроллеры могут использовать методы checkNotModified в WebRequest для поддержки HTTP-кэширования.
________________________________________________________________________________________________________________________
*** Метод ***

- ModelAndView handleRequest(HttpServletRequest request,
                             HttpServletResponse response) - Обработайте запрос и верните объект ModelAndView, который
                                                             будет отображен DispatcherServlet.

Где, параметры: request- текущий HTTP-запрос;
                response- текущий HTTP-ответ;
     возвращает: ModelAndView для рендеринга или null при прямой обработке;
     исключения: Exception - в случае ошибок;
________________________________________________________________________________________________________________________
См. оригинал (ENG):
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/Controller.html
________________________________________________________________________________________________________________________



________________________________________________________________________________________________________________________