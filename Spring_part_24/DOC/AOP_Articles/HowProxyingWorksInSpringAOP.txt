См. исходники и дополнения (ENG):
https://medium.com/walmartglobaltech/understanding-the-worker-ants-of-spring-aop-proxies-902208881493
________________________________________________________________________________________________________________________
****** Понимание принципов АОП Spring: прокси ******

"Если вы хотите, чтобы вам было легко писать код, сделайте его легко читаемым". — Роберт К. Мартин, "Чистый код"

Четкое разделение между основной бизнес-логикой и другими сквозными задачами необходимо для чистого и читаемого кода.
Такие проблемы, как безопасность и управление транзакциями, не являются вашими основными задачами. Смешение их с
бизнес-кодом приводит к жесткой связи с основными функциями, которые могут пострадать в случае их сбоя. Как программист,
я твердо придерживаюсь этого убеждения:

"Не уходите от грязного кода… БЕГИТЕ!!!"

Аспектно-ориентированное программирование (АОП) — это отличная "приспособа" в вашем наборе инструментов, позволяющая
решать проблемы, которые не являются центральными для вашей основной функциональности. АОП позволяет вам добавлять
поведение к существующему коду без изменения кода как такового.

АОП дополняет ООП, предоставляя еще один способ добиться модульности и уменьшить беспорядок в коде. Spring имеет
собственную структуру АОП, которая концептуально проста для понимания и является отличным решением большинства
проблем в корпоративных Java-приложениях.

В этой статье мы собираемся раскрыть тайны черного ящика АОП, чтобы в полной мере раскрыть его истинную мощь и
подчеркнуть его ограничения. Если вы не знакомы с литературой по АОП, загляните сюда -
https://docs.spring.io/spring-framework/reference/core/aop/introduction-defn.html

________________________________________________________________________________________________________________________
*** Прокси и вплетание кода в RunTime (или Runtime Weaving) ***

Прокси — это объект, созданный платформой АОП для реализации аспектных контрактов. Проще говоря, это оболочка экземпляра
компонента, которая поддерживает интерфейс объекта и, при необходимости, добавляет дополнительное поведение. Spring
использует прокси-объекты для автоматического добавления дополнительного поведения без изменения существующего кода.
Это достигается одним из двух способов:
- Динамический прокси JDK - Spring AOP по умолчанию использует динамические прокси JDK, которые позволяют проксировать
                            любой интерфейс (или набор интерфейсов). Всякий раз, когда целевой объект реализует хотя
                            бы один интерфейс, будет использоваться динамический прокси JDK.
- CGLIB прокси - используется по умолчанию, если бизнес-объект не реализует какой-либо интерфейс.

Прокси находится между вызывающим объектом и самим реальным объектом, он может что-то делать до и после вызова целевого
объекта, именно так и действуя Spring AOP.

Целевой объект эффективно оборачивается прокси-объектом во время выполнения. Когда Spring определяет, что компоненту
рекомендован один или несколько аспектов, он генерирует прокси-объект для этого компонента для перехвата вызовов методов
и гарантирует выполнение рекомендаций по мере необходимости.

Экземпляры целевого класса преобразуются в прокси во время запуска приложения или в любой другой момент во время
выполнения перед его использованием. Это называется - Runtime Weaving. Любые вызовы целевых методов соответственно
перехватываются целевыми прокси-классами для выполнения любого подходящего Advice-a.

________________________________________________________________________________________________________________________
*** Прокси в действии ***

Рассмотрим пример для создания аспекта Logger, который регистрирует время, затраченное на каждый метод, помеченный
@Loggable.

- Loggable.java:

************************************************************************************************************************
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Loggable {

}
************************************************************************************************************************

- LoggerAspect.java:

************************************************************************************************************************
@Aspect
@Component
public class LoggerAspect {

    @Pointcut("@annotation(Loggable)")
    public void loggableMethod() {
    }

    @Around("loggableMethod()")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {

        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        String className = methodSignature.getDeclaringType().getSimpleName();
        String methodName = methodSignature.getName();
        final StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        try {
            return joinPoint.proceed();
        } finally {
            stopWatch.stop();
            System.out.println("Execution time for " + className + "." + methodName + " :: " + stopWatch.getTotalTimeMillis() + " ms");
        }
    }
}
************************************************************************************************************************

- Pojo.java:

************************************************************************************************************************
@Component
public class Pojo {

    @Loggable
    public void test(){
        System.out.println("test method called");
        this.testUtil();
    }

    @Loggable
    public void testUtil(){
        System.out.println("testUtil method called");
    }
}
************************************************************************************************************************

- SpringAopDemoApplication.java:

************************************************************************************************************************
@SpringBootApplication
public class SpringAopDemoApplication implements CommandLineRunner {

	@Autowired
	Pojo pojo;

	public static void main(String[] args) {
		SpringApplication.run(SpringAopDemoApplication.class, args);
	}

	@Override
	public void run(String... args){

		pojo.test();
		System.out.println("Out of Test");
		pojo.testUtil();
	}
}
************************************************************************************************************************

См. исходники кода на GitHub Gist: https://gist.github.com/srishtikohli99

После запуска видим:

************************************************************************************************************************
test method called
testUtil method called
Execution time for Test.test :: 18 ms
Out of Test
testUtil method called
Execution time for Test.testUtil :: 0 ms
************************************************************************************************************************

Когда Spring определяет, что тестовый bean (компонент) получает информацию от одного или нескольких аспектов, он
автоматически генерирует для него прокси-объект для перехвата всех вызовов методов и выполнения любых связанных
Advice (рекомендаций), когда это необходимо.

Однако из выходных данных видно, что время выполнения метода регистрируется для вызова pojo.testUtil(), но не для
вызова this.testUtil() в тестовом методе. Почему? Это потому, что последний перехватывается не прокси, а фактическим
целевым классом. В результате Advice никогда не срабатывает.

Давайте посмотрим, что происходит на самом деле, чтобы лучше понять см.
DOC/AOP_Articles/images/AroundAdviceUMLCallDiagram.jpg :

Вызов pojo.test(), предназначенный для Pojo bean, принимается прокси-объектом, который затем вызывает Advice метод.
Затем Advice по кругу напрямую вызывает целевой метод (target method). Как только вызов наконец достигнет целевого
объекта (target object), любые вызовы методов, которые он может выполнить для себя (здесь, this.testUtil()), будут
вызываться по ссылке this, а не по прокси.

Таким образом, вызов самого себя не приводит к соответствующему запуску Advice-a.

!!! Примечание !!! Аннотация @Aspect класса помечает его как аспект и, следовательно, исключает его из автоматического
                   проксирования. Следовательно, невозможно, чтобы аспекты сами по себе были целью Advice от других
                   аспектов в Spring AOP.

________________________________________________________________________________________________________________________
*** Влияние на производительность ***

Поскольку прокси является дополнительным промежуточным звеном между вызывающим кодом и целевым объектом, неудивительно,
что при этом возникают некоторые накладные расходы. Примечательно, что эти накладные расходы фиксированы. Прокси-вызов
добавит фиксированную задержку независимо от времени выполнения простого метода. Фактический вопрос заключается в том,
должны ли мы заботиться об этой задержке? И да и нет!

Если само по себе дополнительное поведение оказывает гораздо большее влияние на производительность (например,
кэширование или управление транзакциями), чем сам механизм проксирования, накладные расходы кажутся незначительными.
Однако, если поведение является детальным и его необходимо применять к большому количеству объектов (например,
протоколирование каждого метода), накладные расходы перестают быть незначительными.

Еще одним поводом для беспокойства является количество проксируемых объектов, участвующих в одном запросе. Если один
запрос включает вызовы сотен или тысяч прокси-методов, накладные расходы становятся значительными, и их нельзя
игнорировать. В тех редких случаях, когда требования не могут быть решены с помощью систем на основе прокси,
предпочтительным является плетение байт-кода (byte code weaving). Переплетение байт-кода использует классы и аспекты и
на выходе создает тканые файлы .class. Поскольку аспекты вплетены непосредственно в код, это обеспечивает лучшую
производительность, но его сложнее реализовать по сравнению с Spring AOP.

________________________________________________________________________________________________________________________
*** ИТОГ ***

Чтобы использовать весь потенциал Spring AOP, жизненно важно понимать тот факт, что Spring AOP основан на прокси-объектах.
Прокси-объект оборачивает объект и прозрачно добавляет дополнительное поведение для решения различных задач (kinds of
concerns). Он имеет большие преимущества, такие как повышенная читаемость кода, упрощенная структура и централизованное
управление.

Прокси-объекты имеют побочные эффекты на производительность, которые, однако, не имеют значения в большинстве случаев.

________________________________________________________________________________________________________________________
*** Рекомендованные материалы ***

- Aspect Oriented Programming with Spring -
https://docs.spring.io/spring-framework/docs/2.5.x/reference/aop.html

- Debunking myths: proxies impact performance -
https://spring.io/blog/2007/07/19/debunking-myths-proxies-impact-performance

________________________________________________________________________________________________________________________