См. исходники и дополнения (ENG):
https://sysout.ru/vvedenie-v-aop-v-spring-boot/
________________________________________________________________________________________________________________________
****** Введение в Spring Boot AOP: шаг за шагом  ******

В этой статье мы с помощью Spring AOP сделаем три вещи:
- Логирование вызовов определенного метода.
- Логирование возвращаемого значения определенного метода при каждом вызове.
- Замер и логирование времени выполнения определенного аннотированного метода при каждом вызове. (Для этого метода
  создадим обычную Java-аннотацию, чтобы пометить метод с помощью нее).

________________________________________________________________________________________________________________________
- ШАГ 1. - Подключение зависимостей:

Чтобы создавать аспекты, в проект Spring Boot необходимо добавить зависимость, в старых версиях Spring-a использовался
Maven и зависимости не подтягивались транзитивно, и все же:

************************************************************************************************************************
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
************************************************************************************************************************

________________________________________________________________________________________________________________________
- ШАГ 2. - Получение задачи:

Итак, допустим, у нас есть некоторый сервис:

************************************************************************************************************************
package ru.sysout.aspectsdemo.service;

import org.springframework.stereotype.Service;
@Service
public class SomeService {

    @LogExecutionTime
    public void someMethod() throws InterruptedException {
        Thread.sleep(1000);
    }

}
************************************************************************************************************************

При каждом вызове метода someMethod() нам надо измерить время его выполнения. В консоль должна выводиться информация о
времени. Допустим, есть еще метод composeFullName() в компоненте:

************************************************************************************************************************
@Component
public class FullNameComposer {

    public String composeFullName(String firstName, String lastName) {
        return firstName + lastName;
    }
}
************************************************************************************************************************

Аналогично, при каждом вызове composeFullName() мы должны выводить в консоль имя метода и возвращаемое им значение.

________________________________________________________________________________________________________________________
*** Дополнительные условия ***

Обратите внимание, что методы *.someMethod() и *.composeFullName() должны находиться в bean-ах, иначе Spring AOP не
сработает. Если у нас не bean-ы, то надо использовать библиотеку AspectJ. Также мы пометили метод *.someMethod()
обычной Java-аннотацией @LogExecutionTime. Для всех методов, помеченных этой аннотацией, мы и будем логгировать время
выполнения.

Выглядит аннотация так:

************************************************************************************************************************
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {
}
************************************************************************************************************************

Решить задачу можно и без аннотации, но поскольку аннотация - это удобный способ пометить метод(ы), покажем, как
работать, в том числе, с ней.

________________________________________________________________________________________________________________________
- ШАГ 3. - Определяем для себя суть происходящего (определяем Aspect):

С помощью выражений мы задаем те методы, для которых будет выполняться определенное действие (будь то логирование
метода или измерение скорости его выполнения). Это действие называется Advice.

Pointcut (точка среза) - это предикат (условие), или выражение, с помощью которого мы выбираем интересные нам методы,
                         а точнее, сама выборка методов.
JoinPoint (точка присоединения) - это точка выполнения программы - а именно, вызов конкретного метода в конкретный
                                  момент времени, когда AOP вмешивается и выполняет наш Advice.

Вся вышеперечисленная логика собирается в коде программы в Aspect.

________________________________________________________________________________________________________________________
- ШАГ 3.1 - Создаем Aspect:

Итак, начнем реализовывать логику. Для этого создадим класс LoggingAspect и пометим его аннотацией @Aspect:

************************************************************************************************************************
@Component
@Aspect
public class LoggingAspect {

    private Logger logger = Logger.getLogger(LoggingAspect.class.getName());
    // Здесь будут advices и pointcuts

}
************************************************************************************************************************

Обратите внимание, что класс должен быть Spring-bean-ом.

________________________________________________________________________________________________________________________
- ШАГ 3.2 - Создаем Pointcut:

Теперь создадим условие выборки этих наших методов, для которых мы решаем нашу задачу. Тут вариантов задать условие
куча, покажем несколько:

- Выбираем все методы класса FullNameComposer (в нашем случае там будет только один метод) (вар.1):

************************************************************************************************************************
@Pointcut("within(ru.sysout.aspectsdemo.service.FullNameComposer)")
public void stringProcessingMethods() {
};
************************************************************************************************************************

Мы создали Pointcut с именем stringProcessingMethods(). Это имя мы будем использовать далее в Advice. На самом деле
необязательно выражение для выборки задавать отдельно в Pointcut, можно сразу в Advice, ниже мы покажем это.

- Выбираем все методы класса FullNameComposer (вар.2):

************************************************************************************************************************
"execution(public String ru.sysout.aspectsdemo.service.FullNameComposer.*(..))"
************************************************************************************************************************

Здесь звездочка означает выбрать все методы класса, а точки означают, что количество и тип аргументов не важны.
Звездочку можно было и вместо возвращаемого типа вставить, это значило бы, что тип не важен.

- Выбираем метод someMethod() класса SomeService (вар.3):

************************************************************************************************************************
"@annotation("@annotation(LogExecutionTime)")"
************************************************************************************************************************

Здесь мы выбираем все методы, помеченные аннотацией @LogExecutionTime.

________________________________________________________________________________________________________________________
- ШАГ 3.3 - Создадим Advice:

Наконец, перейдем к главному — зададим действия, которые выполняются при каждом вызове интересных нам методов. Есть
несколько типов Advice:
- @Before - действие до вызова метода;
- @After - действие после вызова метода (выполняется независимо от того, нормально ли завершился метод или было
           выброшено исключение);
- @AfterReturing - действие после вызова метода (выполняется при нормальном завершении метода);
- @AfterThrowing - действие после вызова метода (выполняется, если было выброшено исключение);
- @Around - действие совершающееся и до и после помеченного метода;

Первый Advice логирует вызовы composeFullName() всегда:

************************************************************************************************************************
@After("stringProcessingMethods()")
public void logMethodCall(JoinPoint jp) {

    String methodName = jp.getSignature().getName();
    logger.log(Level.INFO, "название метода: " + methodName);

}
************************************************************************************************************************

Как видите, в аргументе JoinPoint есть полезная информация о методе.

Создадим второй Advice, который логирует ВОЗВРАЩАЕМОЕ значение в случае нормального завершения метода. У нас он всегда
завершается нормально, но, тем не менее:

************************************************************************************************************************
@AfterReturning(pointcut = "execution(public String ru.sysout.aspectsdemo.service.FullNameComposer.*(..))", returning = "result")
public void logAfterReturning(JoinPoint joinPoint, Object result) {
    logger.log(Level.INFO, "возвращенное значение: " + result.toString());
}
************************************************************************************************************************

Второй аргумент result и есть возвращаемое значение. Заметьте, что Pointcut мы задали прямо в Advice. Как было сказано
выше, так можно делать.

Наконец, последний Advice вычисляет время выполнения метода:

************************************************************************************************************************
@Around("@annotation(LogExecutionTime)")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();
    Object proceed = joinPoint.proceed();
    long executionTime = System.currentTimeMillis() - start;
    logger.log(Level.INFO, joinPoint.getSignature() + " выполнен за " + executionTime + "мс");
    return proceed;
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
- ШАГ 4. - Проверка работоспособности кода:

Давайте сделаем вызовы методов и запустим приложение:

************************************************************************************************************************
@SpringBootApplication
public class AspectsDemoApplication implements CommandLineRunner {

    @Autowired
    FullNameComposer composer;

    @Autowired
    SomeService service;

    public static void main(String[] args) {
        SpringApplication.run(AspectsDemoApplication.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        composer.composeFullName("Ivan", "Petrov");
        service.someMethod();
    }
}
************************************************************************************************************************

В результате в консоли имеем:

************************************************************************************************************************
main] ru.sysout.aspectsdemo.LoggingAspect      : название метода: composeFullName
main] ru.sysout.aspectsdemo.LoggingAspect      : возвращенное значение: IvanPetrov
main] ru.sysout.aspectsdemo.LoggingAspect      : void ru.sysout.aspectsdemo.service.SomeService.someMethod()
                                                 выполнен за 1027мс
************************************************************************************************************************

Код примера есть на GitHub - https://github.com/myluckagain/sysout/tree/master/aspects-demo