См. исходник (RUS): https://habr.com/ru/articles/493676/
________________________________________________________________________________________________________________________
****** Взаимодействия - RPC vs REST vs MQ ******

Remote Procedure Call или «удаленный вызов процедур» представляет собой технологию межпроцессного взаимодействия IPC.
Она позволяет программам вызывать функции и процедуры удаленно таким образом, как‑будто они представлены локально.

MQ или Messages queue - очередь сообщений, это архитектура и ПО промежуточного уровня, которое занимается сбором,
хранение и маршрутизацией (распределением) сообщений между компонентами.

По работе мне довелось провести ряд собеседований на позицию Backend-разработчика. Хорошим для оценки архитектурных
навыков мне кажется следующий вопрос: - Если вам необходимо спроектировать взаимодействие двух систем, в каких случаях
вы выберете RPC, в каких REST, а в каких MQ?

Если ответ на этот вопрос у вас вызывает затруднения, загляните в мой небольшой ЛикБез на эту тему:
________________________________________________________________________________________________________________________
Для начала, нужно определиться концептуально, какие вообще бывают взаимодействия (в самом общем виде).
- Во-первых, вызовы могут быть синхронные и асинхронные. Сам по себе вопрос об этом выборе интересен. И я думаю, что
  очень многие всегда будут отдавать предпочтение асинхронному async/await без конкретной причины — тоже хороший вопрос
  для интервью.
- Во-вторых, модель взаимодействий может быть однонаправленная (one-way) и вызовы вида запрос-ответ. Если вы исповедуете
  CQS, соблюдаете требование идемпотентности, то скорее всего вызовы будут однонаправленными.
- В-третьих, приложения, которые взаимодействуют между собой, могут иметь разную архитектуру, а именно — строение
  доменной логики.

См. https://martinfowler.com/eaaCatalog/index.html
См. DOC/RPCvsRESTvsMQ/1_Domain_Logic.png

________________________________________________________________________________________________________________________
*** Выбор ***

Если предполагается асинхронное взаимодействие, а ответ не требуется - это идеальный случай использовать брокер
сообщений. Положительной стороной такого решения становится устойчивость к сбоям и повышенным нагрузкам.

Выбирая вид взаимодействия для остальных случаев, правильно будет принимать решение, исходя из организации доменной
логики.

________________________________________________________________________________________________________________________
*** Сценарий транзакции ***

Организует бизнес-логику в процедуры, которые управляют каждая своим запросом см.
DOC/RPCvsRESTvsMQ/2_Transaction_Script.gif

Данная форма доменной логики — типичный сценарий хранимой процедуры, который за одну транзакцию выполняет ряд действий
над данными. Иногда такую же форму может иметь микросервис декомпозированный по бизнес-возможности или глаголу. API
подобных процедур нередко может представлять собой набор параметров, часть из которых может передаваться пустыми.

Исходя из определения, данного Мартином Фаулером, вызывать необходимо определённый сценарий и в определённой
последовательности. RPC подход появился именно отсюда. Т.е. подойдут такие протоколы как: Sockets, WebSockets, gRPC,
SOAP и другие.

________________________________________________________________________________________________________________________
*** Обработчик таблицы ***

Одна сущность обрабатывает всю бизнес-логику для всех строк таблицы БД или представления см.
DOC/RPCvsRESTvsMQ/3_Table Handler.gif

Для данной формы организации доменной логики характерна работа над отдельными таблицами, с помощью репозиториев,
реализующих CRUD-операции. Сервис строится с использованием API-Controller — адаптера к репозиторию реализующий
удалённый вызов CRUD-процедур с использованием протокола HTTP. Таким образом, если ваше приложение базируется на
БД с отдельными репозиториями, вам наиболее подходит REST протокол. В ряде случаев, особенно полезным становится
использование протокола OData, расширяющего REST.

________________________________________________________________________________________________________________________
*** Модель предметной области ***

Объектная модель домена, объединяющая данные и поведение см. DOC/RPCvsRESTvsMQ/4_Domain_Model.gif

Это такая форма организации доменной логики, которая взаимодействуют с кластером доменных сущностей — агрегатом. Данное
взаимодействие для соблюдения инвариантов агрегата должно происходить через методы агрегата. Содержание (устройство
агрегата) делает доменную модель значительно более похожей на сценарий транзакции чем на модуль таблицы. Ниже пример
агрегата из книги Эванса см. DOC/RPCvsRESTvsMQ/5_Unit_Design.png

Шаблон доменной модели, как можно видеть, очень похож на сценарий транзакции, но (1) имеет очерченные границы (Bounded
Context), и (2) связан с доменной сущностью (агрегатом). Структура данных при этом сокрыта за абстракцией и может быть в
реляционном виде, а ещё проще когда в нереляционном.

Если сервис делается по принципам предметно-ориентированного проектирования, то есть несколько сложностей. В работе со
своей командой, я столкнулся с тем, что для соблюдения инвариантов сущности, получения больших возможностей
масштабирования, эффективнее всего будет создавать версии агрегата. При этом, если вы корректно оперируете агрегатом
через его методы, классический REST уже не подходит. В частности, для работы с версиями модели, необходимо соблюдать
требование идемпотентности — одна бизнес-операция может изменить соответственно только последнюю версию агрегата.
Корректно в данном случае использовать только глагол POST, с разными DTO разных операций, или конкретным указанием
через маршрутизацию контроллера. Согласитесь — это не REST.

Совершенно по-новому в этом отношении смотрится gRPC — замена Windows Comunication Foundation. С последним очень часто
бывают существенные проблемы соразвития, особенно если интеграция происходит с командой, интеграция с которой оставляет
желать лучшего (т.е. худшие варианты карты контекстов тут не подходят). В рамках же смыслового ядра считаю технологию
оправданной. А сам RPC подход был бы наиболее верным.

Отдельные возможности открываются для брокеров сообщений как средство получения ответа от сервиса, ведь доменная модель
идеально подходит для получения очень чистых событий предметной области, потребителями которых могут быть любые другие
сервисы, а сама ШИНА ДОМЕННЫХ СОБЫТИЙ может стать превосходным средством масштабирования. Организуя 'архитектуру
определяемую событиями', важно не забывать про возможность циклического вызова, про маркеры корреляции.

________________________________________________________________________________________________________________________
*** Дополнительное чтение ***

- Мартин Фаулер - Шаблоны корпоративных приложений - ISBN 978-5-8459-1611-2 - Глава 9. Представление бизнес-логики
- Хоп Грегор, Вульф Бобби - Шаблоны интеграции корпоративных приложений - ISBN 978-5-8459-1946-5
- Эрик Эванс - Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем -
  ISBN 978-5-6040724-9-3
- Крис Ричардсон - Микросервисы. Паттерны разработки и рефакторинга - ISBN 978-5-4461-0996-8 -
  Глава 5. Проектирование бизнес-логики в микросервисной архитектуре.

- Message queue - https://en.wikipedia.org/wiki/Message_queue
- Message-oriented middleware - https://en.wikipedia.org/wiki/Message-oriented_middleware
- Асинхронное общение - https://www.osp.ru/pcworld/2007/03/4198959
________________________________________________________________________________________________________________________
См. комментарии к статье в русском исходнике.