См. исходник (ENG): https://www.baeldung.com/spring-response-entity
________________________________________________________________________________________________________________________
****** Использование Spring ResponseEntity для управления HTTP-ответом ******

Используя Spring, у нас обычно есть много способов достичь одной и той же цели, включая тонкую настройку HTTP-ответов.
В этом коротком руководстве мы увидим, как установить тело, статус и заголовки HTTP-ответа с помощью ResponseEntity.

________________________________________________________________________________________________________________________
*** ResponseEntity ***

ResponseEntity представляет весь ответ HTTP: код состояния, заголовки и тело. В результате мы можем использовать его
для полной настройки HTTP-ответа. Если мы хотим его использовать, нам нужно вернуть его из конечной точки (endpoint);
Об остальном позаботится Spring.

ResponseEntity — это универсальный тип. Следовательно, мы можем использовать любой тип в качестве тела ответа:

************************************************************************************************************************
@GetMapping("/hello")
ResponseEntity<String> hello() {
    return new ResponseEntity<>("Hello World!", HttpStatus.OK);
}
************************************************************************************************************************

Поскольку мы указываем статус ответа программно, мы можем вернуться с разными кодами состояния для разных сценариев:

************************************************************************************************************************
@GetMapping("/age")
ResponseEntity<String> age(
  @RequestParam("yearOfBirth") int yearOfBirth) {

    if (isInFuture(yearOfBirth)) {
        return new ResponseEntity<>(
          "Year of birth cannot be in the future",
          HttpStatus.BAD_REQUEST);
    }

    return new ResponseEntity<>(
      "Your age is " + calculateAge(yearOfBirth),
      HttpStatus.OK);
}
************************************************************************************************************************

Кроме того, мы можем установить HTTP-заголовки:

************************************************************************************************************************
@GetMapping("/customHeader")
ResponseEntity<String> customHeader() {
    HttpHeaders headers = new HttpHeaders();
    headers.add("Custom-Header", "foo");

    return new ResponseEntity<>(
      "Custom header set", headers, HttpStatus.OK);
}
************************************************************************************************************************

Кроме того, ResponseEntity предоставляет два вложенных интерфейса компоновщика: HeadersBuilder и его подинтерфейс
BodyBuilder. Следовательно, мы можем получить доступ к их возможностям через статические методы ResponseEntity.

Самый простой случай — это ответ с телом и кодом ответа HTTP 200:

************************************************************************************************************************
@GetMapping("/hello")
ResponseEntity<String> hello() {
    return ResponseEntity.ok("Hello World!");
}
************************************************************************************************************************

Для наиболее популярных кодов состояния HTTP - https://www.baeldung.com/cs/http-status-codes - мы получаем статические
методы:
- BodyBuilder accepted();
- BodyBuilder badRequest();
- BodyBuilder created(java.net.URI location);
- HeadersBuilder<?> noContent();
- HeadersBuilder<?> notFound();
- BodyBuilder ok();

Кроме того, мы можем использовать методы BodyBuilder status(HttpStatus status) и BodyBuilder status(int status) для
установки любого статуса HTTP. Наконец, с помощью ResponseEntity<T> BodyBuilder.body(T body) мы можем установить тело
ответа HTTP:

************************************************************************************************************************
@GetMapping("/age")
ResponseEntity<String> age(@RequestParam("yearOfBirth") int yearOfBirth) {
    if (isInFuture(yearOfBirth)) {
        return ResponseEntity.badRequest()
            .body("Year of birth cannot be in the future");
    }

    return ResponseEntity.status(HttpStatus.OK)
        .body("Your age is " + calculateAge(yearOfBirth));
}
************************************************************************************************************************

Мы также можем установить собственные заголовки:

************************************************************************************************************************
@GetMapping("/customHeader")
ResponseEntity<String> customHeader() {
    return ResponseEntity.ok()
        .header("Custom-Header", "foo")
        .body("Custom header set");
}
************************************************************************************************************************

Поскольку BodyBuilder.body() возвращает ResponseEntity вместо BodyBuilder, он должен быть последним вызовом.

________________________________________________________________________________________________________________________
!!! Обратите внимание, что с помощью HeaderBuilder мы не можем устанавливать какие-либо свойства тела ответа !!!
________________________________________________________________________________________________________________________

Возвращая объект ResponseEntity<T> из контроллера, мы можем получить исключение или ошибку во время обработки запроса и
хотели бы вернуть информацию, связанную с ошибкой, пользователю, представленному как какой-либо другой тип, скажем, E.

В Spring 3.2 реализована поддержка глобального @ExceptionHandler-а с новой аннотацией @ControllerAdvice см.
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html
и DOC/Exception_Handling, которая обрабатывает подобные сценарии. Более подробную информацию можно найти в нашей
существующей статье здесь - https://www.baeldung.com/exception-handling-for-rest-with-spring.

Хотя ResponseEntity очень мощный инструмент, нам не следует злоупотреблять им. В простых случаях есть и другие варианты,
которые удовлетворяют наши потребности и приводят к более чистому коду.

________________________________________________________________________________________________________________________
*** Альтернативы ***

________________________________________________________________________________________________________________________
*** @ResponseBody ***

В классических приложениях Spring MVC конечные точки обычно возвращают обработанные HTML-страницы. Иногда нам нужно
только вернуть фактические данные; например, когда мы используем конечную точку с AJAX.

В таких случаях мы можем пометить метод обработчика запроса с помощью @ResponseBody, и Spring интерпретирует значение
результата метода как само тело ответа HTTP.

Для получения дополнительной информации см. https://www.baeldung.com/spring-request-response-body

________________________________________________________________________________________________________________________
*** @ResponseStatus ***

Когда конечная точка (endpoint) успешно возвращается, Spring предоставляет ответ HTTP 200 (ОК). Если конечная точка
(endpoint) выдает исключение, Spring ищет обработчик исключений, который сообщает, какой статус HTTP использовать.

Мы можем пометить эти методы @ResponseStatus, и, следовательно, Spring вернется с пользовательским статусом HTTP.

Дополнительные примеры можно найти тут, см. https://www.baeldung.com/spring-response-status

________________________________________________________________________________________________________________________
*** Управляйте ответом напрямую ***

Spring также позволяет нам напрямую обращаться к объекту javax.servlet.http.HttpServletResponse ; нам нужно только
объявить его как аргумент метода:

************************************************************************************************************************
@GetMapping("/manual")
void manual(HttpServletResponse response) throws IOException {
    response.setHeader("Custom-Header", "foo");
    response.setStatus(200);
    response.getWriter().println("Hello World!");
}
************************************************************************************************************************

Поскольку Spring предоставляет абстракции и дополнительные возможности над базовой реализацией, нам не следует
манипулировать ответом таким образом, т.е. - напрямую.

Примеры доступны на GitHub - https://github.com/eugenp/tutorials/tree/master/spring-boot-modules/spring-boot-mvc