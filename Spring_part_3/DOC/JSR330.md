### Использование стандартных аннотаций JSR 330

Начиная со Spring 3.0, Spring предлагает поддержку аннотаций из JSR-330 (Внедрение зависимостей).
Эти аннотации сканируются так же, как и аннотации Spring. Чтобы использовать их, нам необходимо
иметь соответствующие jar-файлы в пути классов (или в файлах настройках Gradle или Maven).

---
### Внедрение зависимостей с помощью @Inject и @Named

Вместо @Autowired мы можем использовать @javax.inject.Inject следующим образом:

**Java:**

        import javax.inject.Inject;
        public class SimpleMovieLister {
            private MovieFinder movieFinder;
            @Inject
            public void setMovieFinder(MovieFinder movieFinder) {
                this.movieFinder = movieFinder;
            }
            public void listMovies() {
                this.movieFinder.findMovies(...);
                // ...
            }
        }

**Kotlin:**

        import javax.inject.Inject
        class SimpleMovieLister {
            @Inject
            lateinit var movieFinder: MovieFinder
            fun listMovies() {
                movieFinder.findMovies(...)
                // ...
            }
        }

Как и в случае с @Autowired, мы можем использовать @Inject на уровне поля, метода и аргумента
конструктора. Более того, вы можете объявить свою точку внедрения как Provider, что позволит
получить доступ по требованию к bean-ам с более узкой областью видимости или отложенный доступ
к другим bean-ам через вызов Provider.get().

В следующем примере предложен вариант предыдущего примера:

**Java:**

        import javax.inject.Inject;
        import javax.inject.Provider;
        public class SimpleMovieLister {
            private Provider<MovieFinder> movieFinder;
            @Inject
            public void setMovieFinder(Provider<MovieFinder> movieFinder) {
                this.movieFinder = movieFinder;
            }
            public void listMovies() {
                this.movieFinder.get().findMovies(...);
                // ...
            }
        }

**Kotlin:**

        import javax.inject.Inject
        class SimpleMovieLister {
            @Inject
            lateinit var movieFinder: Provider<MovieFinder>
            fun listMovies() {
                movieFinder.get().findMovies(...)
                // ...
            }
        }

Если необходимо использовать полное имя для зависимости, которую нужно внедрить, нам потребуется
использовать аннотацию @Named, как показано в следующем примере:

**Java:**

        import javax.inject.Inject;
        import javax.inject.Named;
        public class SimpleMovieLister {
            private MovieFinder movieFinder;
            @Inject
            public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
                this.movieFinder = movieFinder;
            }
            // ...
        }

**Kotlin:**

        import javax.inject.Inject
        import javax.inject.Named
        class SimpleMovieLister {
            private lateinit var movieFinder: MovieFinder
            @Inject
            fun setMovieFinder(@Named("main") movieFinder: MovieFinder) {
                this.movieFinder = movieFinder
            }
            // ...
        }

Как и @Autowired, @Inject также можно использовать с java.util.Optional или @Nullable. Это тем более
применимо в данном случае, поскольку @Inject не имеет required атрибута. Следующая пара примеров
показывает, как использовать @Inject и @Nullable:

        public class SimpleMovieLister {
            @Inject
            public void setMovieFinder(Optional<MovieFinder> movieFinder) {
                // ...
            }
        }

**Java:**

        public class SimpleMovieLister {
            @Inject
            public void setMovieFinder(@Nullable MovieFinder movieFinder) {
                // ...
            }
        }

**Kotlin:**

        class SimpleMovieLister {
            @Inject
            var movieFinder: MovieFinder? = null
        }

---
### @Named и @ManagedBean: Стандартные эквиваленты аннотации @Component

Вместо @Component можно использовать @javax.inject.Named или javax.annotation.ManagedBean, как
показано в следующем примере:

**Java:**

        import javax.inject.Inject;
        import javax.inject.Named;
        @Named("movieListener")  // можно также использовать @ManagedBean("movieListener")
        public class SimpleMovieLister {
            private MovieFinder movieFinder;
            @Inject
            public void setMovieFinder(MovieFinder movieFinder) {
                this.movieFinder = movieFinder;
            }
            // ...
        }

**Kotlin:**

        import javax.inject.Inject
        import javax.inject.Named
        @Named("movieListener")  // можно также использовать @ManagedBean("movieListener")
        class SimpleMovieLister {
            @Inject
            lateinit var movieFinder: MovieFinder
            // ...
        }

Очень часто используется @Component без указания имени компонента. Аналогичным образом можно
использовать @Named, как показано в следующем примере:

**Java:**

        import javax.inject.Inject;
        import javax.inject.Named;
        @Named
        public class SimpleMovieLister {
            private MovieFinder movieFinder;
            @Inject
            public void setMovieFinder(MovieFinder movieFinder) {
                this.movieFinder = movieFinder;
            }
            // ...
        }

**Kotlin:**

        import javax.inject.Inject
        import javax.inject.Named
        @Named
        class SimpleMovieLister {
            @Inject
            lateinit var movieFinder: MovieFinder
            // ...
        }

Если мы задействуем @Named или @ManagedBean, то использовать сканирование компонентов можно точно
так же, как и при использовании аннотаций Spring, как показано в следующем примере:

**Java:**

        @Configuration
        @ComponentScan(basePackages = "org.example")
        public class AppConfig  {
            // ...
        }

**Kotlin:**

        @Configuration
        @ComponentScan(basePackages = ["org.example"])
        class AppConfig  {
            // ...
        }

В отличие от @Component, аннотации @Named из JSR-330 и @ManagedBean из JSR-250 не являются составными.
Для создания специальных аннотаций компонентов следует использовать модель стереотипов Spring.

---
### Ограничения стандартных аннотаций JSR-330

При работе со стандартными аннотациями следует знать, что некоторые важные функции будут недоступны,
как показано в следующей таблице:

|Spring	              | javax.inject.*	      |  ограничения/комментарии javax.inject
|---------------------|-----------------------|------------------------------------------------------------
|@Autowired           | @Inject               |  У @Inject нет атрибута "required". Вместо этого можно использовать Optional из Java 8
|@Component           | @Named / @ManagedBean |  JSR-330 не предоставляет составную модель, только способ идентификации именованных компонентов.
| @Scope("singleton") | @Singleton            |  Область доступности по умолчанию из JSR-330 похожа на область доступности на уровне prototype из Spring. Однако для того, чтобы соответствовать общим настройкам Spring, бин из JSR-330, объявленный в контейнере Spring, по умолчанию является singleton. Чтобы использовать область доступности, отличную от singleton, необходимо использовать аннотацию @Scope из Spring. javax.inject также предоставляет возможность использовать аннотацию @Scope. Тем не менее, она предназначена только для создания собственных аннотаций.
| @Qualifier          | @Qualifier / @Named   |  javax.inject.Qualifier – это просто мета-аннотация для создания кастомных квалификаторов. Конкретные String квалификаторы (наподобие @Qualifier из Spring с некоторым значением) могут быть связаны через javax.inject.Named.
| @Value              | -                     |  без эквивалента
| @Required           | -                     |  без эквивалента
| @Lazy               | -                     |  без эквивалента
| ObjectFactory       | Provider              |  javax.inject.Provider является прямой альтернативой ObjectFactory из Spring, только с более коротким именем метода get(). Его также можно использовать в сочетании с @Autowired из Spring или с неаннотированными конструкторами и сеттерами.
