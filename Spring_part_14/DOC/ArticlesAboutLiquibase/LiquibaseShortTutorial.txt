Исходная статья: https://www.cloudbees.com/blog/liquibase-tutorial-manage-database-schema
________________________________________________________________________________________________________________________
****** Учебное пособие по Liquibase: научитесь управлять схемой базы данных ******

Liquibase — один из самых универсальных инструментов для миграции баз данных см. DOC/DatabaseMigration.txt. Он работает
практически на всех платформах баз данных SQL. Так что, используете ли вы MySQL, SQL Server, Oracle, Firebird или
комбинацию этих или любых других распространенных платформ баз данных, это поможет вам. Он также работает в любом
конвейере CI/CD, если вы можете запускать Java, устанавливать соединители и подключаться к своим базам данных.

Это означает, что вы можете использовать Liquibase для развертывания изменений базы данных вместе с новыми функциями,
выпущенными после переключения функций. Это требует некоторого планирования, особенно когда вы выпускаете противоречивые
или разрушительные изменения.

К счастью, у Liquibase есть инструменты, позволяющие сделать изменения в базе данных менее болезненными. Он выполняет
все операции DDL и несколько очень полезных рефакторингов. Иногда вам нужно быть осторожным при запуске этих изменений
базы данных на ваших рабочих экземплярах, поскольку они могут заблокировать ваши таблицы на долгое время.

Тут вы узнаете, как использовать Liquibase, чтобы упростить миграцию баз данных.

________________________________________________________________________________________________________________________
*** Как работает Liquibase? ***

Изменения определяются на независимом от платформы языке и переводятся на любую используемую вами платформу базы данных.
По сути, вы ведете действующий список изменений, и Liquibase применяет эти изменения за вас через свой механизм
выполнения. Поскольку он работает на Java, для обновления базы данных ему необходим правильный драйвер JDBC. И, конечно
же, вам потребуется установить последнюю версию JRE.

Поскольку Liquibase запускается из оболочки или командной строки, вы можете запустить его вручную или из любого
используемого вами конвейера развертывания. Liquibase отслеживает изменения, используя свои собственные таблицы в
вашей схеме, чтобы обеспечить согласованность и избежать повреждений из-за неправильно измененных журналов изменений.

Он записывает хэш каждого набора изменений. Во время запуска обновлений он "блокирует" или "lock-ирует" вашу базу
данных, чтобы вы не могли случайно запустить два журнала изменений одновременно.

________________________________________________________________________________________________________________________
*** Знакомьтесь с журналами изменений - Changelogs ***

Журналы изменений пишутся на предметно-ориентированных языках. Вы можете написать их в JSON, YAML, XML или в одном из
нескольких других поддерживаемых форматов. Журналы изменений состоят из серии наборов изменений. Набор изменений
представляет собой одно изменение в вашей базе данных.

Некоторые примеры включают создание таблицы, добавление столбца в таблицу и добавление индекса. Вы также можете включить
операторы SQL в журнал изменений. Журнал изменений (Changelogs) должен храниться под контролем версий. Когда вы вносите
изменения, вы добавляете новый набор изменений в конец журнала изменений. Вы никогда не станете изменять существующий
набор изменений.

Давайте рассмотрим некоторые распространенные изменения схемы с использованием различных синтаксисов журналов изменений
(Changelogs), чтобы дать вам лучшее представление о том, как это работает.
________________________________________________________________________________________________________________________
*** Применить изменения схемы ***

Добавление таблицы — это обычное изменение, которое вы увидите в любом журнале изменений Liquibase. В следующем примере
показано, как можно добавить две таблицы, используя журнал изменений в формате XML:

************************************************************************************************************************
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog/1.9"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog/1.9
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd">
  <changeSet author="philn5d" id="users_db_1.0.0">
    <createTable tableName="users">
      <column name="id" type="INT" autoIncrement="true">
        <constraints nullable="false" primaryKey="true" />
      </column>
      <column name="username" type="VARCHAR(100)">
        <constraints nullable="false" unique="true" />
      </column>
    </createTable>
  </changeSet>
  <changeSet author="philn5d" id="users_db_1.0.1">
    <createTable tableName="accounts">
      <column name="id" type="INT" autoIncrement="true">
        <constraints nullable="false"
                     primaryKey="true" />
      </column>
      <column name="owner_id" type="INT">
        <constraints nullable="false"
                     references="users(id)"
                     foreignKeyName="FK_accounts_users" />
      </column>
    </createTable>
  </changeSet>
</databaseChangeLog>
************************************************************************************************************************

Здесь у нас есть журнал изменений с двумя наборами изменений. Каждый набор изменений создает новую таблицу. Вторая
таблица ссылается на первую с помощью внешнего ключа в столбце «owner_id». Если мы хотим обновить одну из этих двух
таблиц, например, добавив столбец в таблицу пользователей, мы должны добавить новый набор изменений.

Давайте рассмотрим набор изменений для добавления имени учетной записи в таблицу учетных записей с использованием
формата JSON. Поскольку вы добавите это в существующий журнал изменений, давайте представим, что приведенный выше журнал
изменений был написан в формате JSON, и мы добавляем к нему следующее:

************************************************************************************************************************
{
  "databaseChangeLog": [
    { ... },
    { ... },
    {
      "changeSet": {
        "id": "users_db_1.0.2",
        "author": "philn5d",
        "changes": [
          {
            "addColumn": {
              "columns": [
                {
                  "column": {
                    "name": "name",
                    "type": "varchar(255)"
                  }
                }
              ],
              "tableName": "accounts"
            }
          }
        ]
      }
    }
  ]
}
************************************************************************************************************************

В этом примере набор изменений добавляется в конец массива JSON. Этот набор изменений добавляет столбец в таблицу счетов.

Давайте рассмотрим еще один пример, на этот раз в YAML. Для этого мы рассмотрим действие отката. Liquibase рекомендует
включать откаты в ваши наборы изменений, поэтому вот как бы вы включили откат в предыдущий набор изменений, если бы он
был в YAML:

************************************************************************************************************************
databaseChangeLog:
  - changeSet:
     ...
  - changeSet:
    ...
  - changeSet:
      id: users_db_1.0.2
      author: philn5d
      changes:
        - addColumn:
            columnName: name
          tableName: accounts
      rollback:
        - dropColumn:
            columnName: name
            tableName: accounts
************************************************************************************************************************

Опять же, это набор изменений, который добавляет столбец имени. Это происходит после первых двух наборов изменений.
Здесь мы видим добавление «отката» в набор изменений. Многие изменения поддерживают автоматический откат, поэтому вам
не нужно включать явный откат.

В документации Liquibase есть примечания о поддержке каждой из поддерживаемых баз данных. « addColumn » см.
https://docs.liquibase.com/change-types/add-column.html, например, автоматически откатится, поэтому нет необходимости
включать откат, показанный в примере выше. Со схемой можно делать практически все, что угодно, включая, среди прочего,
манипулирование представлениями, хранимыми процедурами, функциями и триггерами.

Однако к хранимым процедурам и функциям следует относиться особым образом. Мы рассмотрим их позже, но сначала несколько
предостережений по поводу добавления индекса с этими журналами изменений (changelogs).

________________________________________________________________________________________________________________________
*** Индекс с осторожностью ***

Иногда создание индекса занимает много времени. Во время создания индекса таблица может быть заблокирована, что сделает
приложение бесполезным во время заполнения индекса. Есть некоторые вещи, которые вы можете сделать, чтобы снизить риски
воздействия на приложение при использовании Liquibase.

Единственное, что вы можете сделать - это не добавлять индексы с помощью Liquibase.

Иногда нам действительно нужно индексировать таблицы в рабочей среде только для решения проблем с производительностью.
Вероятно, это не лучшее решение, поскольку вам придется отслеживать все изменения в инструменте миграции базы данных.
Как всегда, делайте то, что лучше в вашей ситуации. Еще одна вещь, которую вы можете сделать - это запустить обновления
в течение определенного окна обслуживания.

Неизвестно, сколько времени займет операция индексирования, поэтому будьте осторожны при ее добавлении. Есть несколько
стратегий, которые вы можете использовать при добавлении индекса. Вы можете использовать гибридный подход. Примените
индекс в рабочей среде, когда это будет безопасно, а затем добавьте его в журнал изменений с предварительным условием
«exists».

Liquibase учитывает предварительные условия, которые должны быть выполнены для запуска набора изменений. Одним из таких
предварительных условий является «indexExists». Вы должны добавить следующий набор изменений, чтобы добавить индекс в
таблицу «users»:

************************************************************************************************************************
changeSet:
  id: users_db_1.0.3
  author: philn5d
  changes:
    - preConditions:
        - onFail: CONTINUE
          not:
            - indexExists:
                schemaName: users
                indexName: IX_users_name
    - createIndex:
        schemaName: users
        indexName: IX_users_name
        columns:
          - column:
              name: username
              type: VARCHAR(100)
************************************************************************************************************************

Предварительное условие, приведенное выше, должно пропустить этот набор изменений, если индекс уже существует. Без
предварительного условия весь журнал изменений завершится сбоем, когда Liquibase попытается запустить оператор создания
индекса в базе данных, когда она достигнет этого набора изменений. Предварительное условие предотвращает эту проблему.

Другой способ контролировать изменения — запускать сценарий (script) при изменении определения (definition) базового
объекта.

Управляете хранимыми процедурами и функциями с помощью Liquibase см. ниже.

________________________________________________________________________________________________________________________
*** Управление хранимыми процедурами ***

Лучше всего хранить определения (definition) хранимых процедур и функций в файлах SQL под контролем исходного кода. Это
позволяет уменьшить размер наборов изменений. Это также упрощает управление изменениями. Вы можете поместить все
определение в набор изменений, но когда вам нужно изменить какую-либо хранимую процедуру, вам придется открыть весь
файл журнала изменений.

Ваш редактор не будет хорошо работать с файлом журнала изменений, содержащим смесь SQL и XML, YAML или JSON. Гораздо
проще редактировать SQL непосредственно в его собственном файле. Вам также будет легче сравнивать изменения в коммитах,
а также в отдельных объектах.

Есть как минимум два способа написать набор изменений:
- Вы можете использовать команду createProcedure или команду sqlFile. В зависимости от стека вашей базы данных вам
  придется использовать разные методы «СОЗДАНИЯ ИЛИ ИЗМЕНЕНИЯ» процедуры или функции. Возможно, вам придется включить
  в набор изменений отдельную команду, чтобы удалить объект, прежде чем пытаться создать хранимую процедуру или функцию.
  Несмотря на эти аномалии, специфичные для базы данных, это гораздо более простой подход к обслуживанию объектов SQL
  такого типа по сравнению с использованием инструмента сравнения.
- Также легко поддерживать «данные списка» с помощью Liquibase. Есть несколько способов внесения изменений в данные. Мы
  проверим это дальше...

________________________________________________________________________________________________________________________
*** Внесите изменения в данные ***

Помимо управления объектами, Liquibase хороша для хранения данных. Некоторые данные представляют собой списки данных,
специфичных для домена, а не пользовательских данных. Примером этого могут быть типы кузовов автомобилей. Таблицы,
содержащие эти данные, также известны как «таблицы поиска».

Liquibase позволяет загружать данные в таблицы, создавать таблицы поиска из существующих таблиц и перезагружать таблицы.
Конечно, вы всегда можете создать свои собственные файлы SQL, чтобы загрузить таблицы поиска и запустить их в Liquibase.
Команда «loadUpdateData» полезна для загрузки тестовых данных в дополнение к данным поиска. Эта команда либо вставит,
либо заменит данные, указанные в файле CSV. Мы не будем вдаваться в подробности, но это позволяет вам отображать данные
в столбцы по мере необходимости.

Пользовательский сценарий можно реализовать с помощью команды «sqlFile». Когда вы вносите изменения в данные, вы можете
использовать «контексты» для применения наборов изменений в зависимости от контекста. Например, вы можете захотеть
заменить данные базовыми тестовыми данными в тестовой среде. В этом случае вы будете запускать «loadUpdateData» только
для определенных таблиц в «тестовом» контексте.

Контекст передается Liquibase в качестве аргумента при его запуске (с помощью сценария или инструмента развертывания).
Все это замечательно, когда вы вносите изменения и запускаете собственные развертывания. Но что, если для обновления
базы данных вам придется обращаться к администратору базы данных?

У Liquibase есть выход. Вот как...

________________________________________________________________________________________________________________________
*** Генерация сценариев администратора базы данных ***

Когда вы будете готовы запустить обновления, вы можете либо поручить Liquibase выполнить их за вас, используя локальный
драйвер JDBC, либо создать SQL-скрипт для внесения изменений.

Вы можете передать этот сценарий своим администраторам баз данных, чтобы они могли просмотреть и запустить его в
соответствии с вашим процессом выпуска. Генерация SQL также удобна, если вы хотите проверить свой набор изменений без
выполнения операций с базой данных. Вы можете вывести SQL на стандартный вывод или перенаправить его в файл.

************************************************************************************************************************
# SQL to stdout
java -jar liquibase.jar ... updateSQL

# or redirect SQL to file
java -jar liquibase.jar ... updateSQL > /changes.sql
************************************************************************************************************************

За исключением других аргументов jar Liquibase, эти примеры показывают, как генерировать SQL, а не обновлять базу данных.

ИТОГ: Надеюсь, вам понравилось это введение в управление миграцией баз данных с помощью Liquibase. Вам следует прочитать
      документацию см. https://docs.liquibase.com/home.html, чтобы получить полную информацию о том, как выполнять
      обновления.

      Это, безусловно, то, что поможет вам в вашем постоянном совершенствовании. В сочетании с другими методами, такими
      как флаги функций , это может серьезно сократить время вашего цикла, что может означать разницу между успехом
      ваших продуктов и отставанием от конкурентов.