****** @ElementCollection ******

JPA 2.0 определяет ElementCollection как механизм сопоставления (mapping-a). Он предназначен для обработки
сопоставлений нескольких нестандартных взаимосвязей. ElementCollection можно использовать для определения
взаимосвязи «один ко многим» к Embeddable (встраиваемому,
см. https://github.com/JcoderPaul/Hibernate_Lessons/blob/master/Hibernate_part_2/DOC/HibernateEmbeddableEmbedded.txt)
объекту или Basic значению (например, коллекции String s). ElementCollection также можно использовать в сочетании
с MAP для определения взаимосвязи, где ключ может быть объектом любого типа, а значение — объектом или значением.

В JPA ElementCollection связь задается через аннотацию @ElementCollection или <element-collection> элемент в файле
настройке *.XML.

Значения ElementCollection всегда сохраняются в отдельной таблице. Таблица определяется через @CollectionTable
аннотацию или <collection-table> элемент *.XML файла настройки. Определяет CollectionTable таблицу name и
@JoinColumn / @JoinColumns или составной первичный ключ.

----------------------------------------------------------------------------------------------------------------
*** Embedded Collections ***

В данном случае описывается ситуация с применением Embedded (встроенных) сущностей, когда для организации
взаимосвязи и настройки приходится создавать отдельную сущность аннотированную как - @Embeddable, см. ниже.

Взаимосвязь настроенная при помощи ElementCollection может использоваться для описания коллекций Embeddable
элементов. Это нетипичное использование Embeddable объектов, поскольку эти объекты не встроены в таблицу исходного
объекта, а хранятся в отдельной таблице коллекции. Это похоже на OneToMany взаимосвязь, за исключением того, что
целевым объектом Embeddable является Entity. Это позволяет легко определять (очерчивать, описывать) коллекции
простых объектов, не требуя, чтобы простые объекты описывали (определяли) Id или ManyToOne обратный маппинг
(настроенную взаимосвязь). ElementCollection также может переопределить сопоставления или таблицу для своей
коллекции, поэтому вы можете иметь несколько сущностей, ссылающихся на один и тот же Embeddable класс, но каждый
из них хранит свои зависимые объекты в отдельной таблице.

Ограничения использования @ElementCollection вместо @OneToMany заключаются в том, что целевые объекты нельзя
запрашивать, сохранять и объединять независимо от их родительского объекта. Это строго частные (зависимые)
объекты, такие же, как и при Embedded отображении. Для объекта нет cascade опции ElementCollection, целевые
объекты всегда сохраняются, объединяются и удаляются со своим родителем. ElementCollection по-прежнему может
использовать fetch тип и значения по умолчанию LAZY такие же, как и другие сопоставления коллекций.

Пример базы данных (имеем два таблицы):

EMPLOYEE (table)
-----------------------------------
EMP_ID | F_NAME | L_NAME | SALARY
-----------------------------------
1      | Bob    | Way    | 50000
-----------------------------------
2      | Joe    | Smith  | 35000
-----------------------------------

PHONE (table)
-------------------------------------------
OWNER_ID | TYPE | AREA_CODE | P_NUMBER
-------------------------------------------
1        | home | 613       | 792-0001
-------------------------------------------
1        | work | 613       | 494-1234
-------------------------------------------
2        | work | 416       | 892-0005
-------------------------------------------

Применяем аннотацию @ElementCollection для описания взаимосвязи таблиц:

****************************************************************************************************************

@Entity
public class Employee {

  @Id
  @Column(name="EMP_ID")
  private long id;

  ...

  @ElementCollection
  @CollectionTable(
        name="PHONE",
        joinColumns=@JoinColumn(name="OWNER_ID")
  )
  private List<Phone> phones;

  ...

}

@Embeddable
public class Phone {
  private String type;
  private String areaCode;

  @Column(name="P_NUMBER")
  private String number;

  ...

}

****************************************************************************************************************

*** Пример XML-связи ElementCollection с Embedded сущностями ***

****************************************************************************************************************
<entity name="Employee" class="org.acme.Employee" access="FIELD">
    <attributes>
        <id name="id">
            <column name="EMP_ID"/>
        </id>
        <element-collection name="phones">
            <collection-table name="PHONE">
                <join-column name="OWNER_ID"/>
            </collection-table>
        </element-collection>
    </attributes>
</entity>
<embeddable name="Phone" class="org.acme.Phone" access="FIELD">
    <attributes>
        <basic name="number">
            <column name="P_NUMBER"/>
        </basic>
    </attributes>
</embeddable>
****************************************************************************************************************

----------------------------------------------------------------------------------------------------------------
*** Basic Collections ***

В данном случае описывается ситуация с применением простых объектов, когда для организации взаимосвязи и
настройки таблиц ненужно создавать отдельную сущность аннотированную как - @Embeddable, см. ниже., все
происходит внутри одной сущности.

Маппинг с использованием ElementCollection можно применять для описания взаимосвязи коллекции Basic объектов.
Значения Basic объекта хранятся в отдельной таблице. Данная связь похожа на взаимосвязь OneToMany, за исключением
того, что целью является Basic (примитив) значение, а не Entity. Это позволяет легко описывать коллекции простых
значений без необходимости определения класса для этих самых значений.

Тут нет возможности использовать cascade опции для ElementCollection, целевые объекты всегда сохраняются,
объединяются и удаляются со своим родителем (нет родителя нет связного с ним объекта). ElementCollection
по-прежнему может использовать fetch тип и значения по умолчанию LAZY, как и другие сопоставления (mapping)
коллекций.

Пример базы данных с применением простых значений:

EMPLOYEE (table)
-----------------------------------
EMP_ID | F_NAME | L_NAME | SALARY
-----------------------------------
1      | Bob    | Way    | 50000
-----------------------------------
2      | Joe    | Smith  | 35000
-----------------------------------

PHONE (table)
--------------------------
OWNER_ID | PHONE_NUMBER
--------------------------
1        | 613-792-0001
--------------------------
1        | 613-494-1234
--------------------------
2        | 416-892-0005
--------------------------

Пример применения аннотации @ElementCollection с Basic объектами:

****************************************************************************************************************
@Entity
public class Employee {

  @Id
  @Column(name="EMP_ID")
  private long id;

  ...

  @ElementCollection
  @CollectionTable(
        name="PHONE",
        joinColumns=@JoinColumn(name="OWNER_ID")
  )
  @Column(name="PHONE_NUMBER")
  private List<String> phones;

  ...

}
****************************************************************************************************************

*** Пример XML-связи ElementCollection с Basic объектами ***

****************************************************************************************************************
<entity name="Employee" class="org.acme.Employee" access="FIELD">
    <attributes>
        <id name="id">
            <column name="EMP_ID" />
        </id>
        <element-collection name="phones" target-class="java.lang.String">
            <column name="PHONE_NUMBER" />
            <collection-table name="PHONE">
                <join-column name="OWNER_ID" />
            </collection-table>
        </element-collection>
    </attributes>
</entity>
****************************************************************************************************************

----------------------------------------------------------------------------------------------------------------
*** Распространенные проблемы при использовании @CollectionTable ***

Спецификация JPA 2.0 не предоставляет возможности определить Id в помеченной Embeddable сущности. Однако для
удаления или обновления элемента сопоставления обычно требуется ElementCollection некоторый уникальный ключ.
В противном случае при каждом обновлении поставщику JPA придется удалять все из CollectionTable для Entity,
а затем вставлять значения обратно. Таким образом, поставщик JPA, скорее всего, предположит, что комбинация
всех полей Embeddable сущности в сочетании с внешним ключом (JoinColumn(ами)) уникальна. Однако это может быть
неэффективно или просто неосуществимо, если объект Embeddable большой или сложный.

Некоторые поставщики JPA могут разрешить указывать ID в Embeddable сущностях, чтобы решить эту проблему.
Обратите внимание, что в этом случае ID уникальный ключ должен быть только для коллекции, а не для таблицы,
поскольку включен внешний ключ. Некоторые могут также разрешить использовать для этого unique опцию у
CollectionTable. В противном случае, если ваш Embeddable объект сложный, следует подумать о том, чтобы сделать
его Entity и использовать OneToMany вместо текущей конфигурации взаимосвязи.