****** Управление транзакциями в Spring: @Transactional в деталях ******

Данное краткое руководство пригодится, для того чтобы получить простое и практическое понимание, как работает
управление транзакциями в Spring с помощью аннотации @Transactional .

Содержание данной статьи пересекается с другим материалом см. DOC/TransactionInSpring/TransactionInSpring.txt

Аннотация @Transactional связанна с декларативным управлением транзакциями, против TransactionTemplate -
программного управления транзакциями (DOC/AnnotationTransactional/TransactionTemplate.txt). В официальной
документации по управлению транзакциями в Spring Core:

*****************************************************************************************************************
https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/data-access.html#transaction
*****************************************************************************************************************

можно найти полное описание:
- интеграции @Transactional Spring и JPA / Hibernate;
- интеграции @Transactional Spring и Spring Boot или Spring MVC;
- особенности работы откатов транзакций, проксирования объектов, общих проблем и т.п.

Во многих статьях изучение транзакций в Spring начинают с повторения принципов управления транзакциями в JDBC.
Потому что всё, что делает Spring, построено на основах JDBC (соединение с базами данных на Java, открытие и
закрытие транзакций, commit-ы и rollback-и), см. https://en.wikipedia.org/wiki/Java_Database_Connectivity. Нужно
помнить, что Spring это framework, а многие фреймворки просто берут 'старое доброе' и поднимают его на новый
уровень абстракции, улучшая и упрощая функционал.

-----------------------------------------------------------------------------------------------------------------
*** Управление транзакциями JDBC ***

Не имеет значения, используем ли мы аннотацию @Transactional от Spring, обычный Hibernate или любую другую
библиотеку БД - в конечном счёте, все они делают одно и то же: открывают и закрывают ("управляют") транзакциями БД.

Обычный код управления транзакциями JDBC выглядит следующим образом:

*****************************************************************************************************************
import java.sql.Connection;
...

Connection connection = dataSource.getConnection(); /* (1) */

try (connection)
    {
        connection.setAutoCommit(false); /* (2) */
        // выполнить несколько SQL-запросов...
        connection.commit(); /* (3) */

    }
catch (SQLException e)
    {
        connection.rollback(); /* (4) */
    }
...
*****************************************************************************************************************

Шаг 1. Соединение с БД. Для запуска транзакций необходимо подключение к базе данных, как вариант можно использовать -
       DriverManager.getConnection(url, user, password), хотя в большинстве корпоративных приложений мы будем иметь
       настроенный источник данных и получать соединения из него (адаптированная копия текста из см.
       DOC/TransactionInSpring/TransactionInSpring.txt).

Шаг 2. Начинаем (получаем) транзакцию БД в Java из соединения - setAutoCommit(true) - устанавливаем авто-коммит,
       и в таком случае гарантируем, что каждый SQL-оператор будет автоматически завёрнут в собственную транзакцию.
       В случае установки - setAutoCommit(false) - мы получаем возможность самостоятельно управлять транзакциями,
       т.е мы будем 'вручную' вызывать commit и rollback.

       См. док. (ENG): https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html

       !!! Обратите внимание, что флаг autoCommit действует в течение всего времени, пока наше соединение открыто,
       что означает, что нам нужно вызвать метод только один раз !!!

Шаг 3. Фиксируем (commit) транзакцию в случае успеха (мы не поймали исключение).

Шаг 4. Откатываем транзакцию (rollback изменений), если произошло исключение.

В упрощенном виде Spring делает эти 4-и шага всякий раз, когда мы используем аннотацию @Transactional.

!!! Внимание !!! Библиотеки пулов соединений, такие как HikariCP, могут переключать режим авто-коммита
                 автоматически, в зависимости от конфигурации. См. док.

-----------------------------------------------------------------------------------------------------------------
*** Уровни изоляции JDBC и точки сохранения ***

Аннотация @Transactional от Spring (с параметрами) выглядит примерно так:

*****************************************************************************************************************
@Transactional(
  propagation=TransactionDefinition.NESTED,
  isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED
)
*****************************************************************************************************************

*****************************************************************************************************************
См. док. (ENG): https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html
*****************************************************************************************************************

Необходимо знать и помнить, что все эти параметры сводятся к следующему, основному коду JDBC:

*****************************************************************************************************************
import java.sql.Connection;

...
/* isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED */

connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); /* (1) */

/* propagation=TransactionDefinition.NESTED */

Savepoint savePoint = connection.setSavepoint(); /* (2) */
...
connection.rollback(savePoint);
*****************************************************************************************************************

Краткое описание настроек см. DOC/AnnotationTransactional/TransactionalAnnotation.txt

Вложенные транзакции в Spring - это точки сохранения JDBC / базы данных (savepoints), для понимания особенностей
этого момента см. руководство (ENG): https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html

!!! Обратите внимание !!! Поддержка точек сохранения зависит от выбранного драйвера JDBC/базы данных.

-----------------------------------------------------------------------------------------------------------------
*** Управление транзакциями в Spring и Spring boot ***

И так, мы освежили понимание того, как работают транзакций в JDBC. А поскольку Spring core (Spring boot и
Spring MVC) управляет транзакциями на основе принципов JDBC, то получается, что Spring делает тоже самое:
- запускает транзакции;
- фиксирует транзакции в случае успеха;
- откатывает транзакции в случае провала;

Однако, если, в обычном JDBC у нас есть только один способ управлять транзакциями через setAutocommit(false),
то Spring предлагает нам как минимум два варианта, добиться того же самого:
- программное управление транзакциями Spring-а;
- декларативное управление транзакциями Spring-а;

-----------------------------------------------------------------------------------------------------------------
*** Программное управление транзакциями Spring (Programmatic Transaction Management) ***

Первый, но довольно редко используемый способ определения транзакций в Spring - программный. Использование
транзакционного шаблона TransactionTemplate (см. DOC/AnnotationTransactional/TransactionTemplate.txt), либо
непосредственно через PlatformTransactionManager.

С точки зрения кода это выглядит следующим образом:

*****************************************************************************************************************
@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            /*
            Выполнить некий SQL запрос, который, например, вставляет
            пользователя в базу данных и возвращает авто-сгенерированный
            идентификатор.
            */
          return id;
        });
    }
}
*****************************************************************************************************************

Если сравнить с обычным примером JDBC приведенным выше, мы получаем следующие ништяки:
- нам не нужно возиться с открытием и закрытием соединений с БД самостоятельно (try-finally). Вместо этого мы
  используем обратные вызовы транзакций (TransactionCallback);
- нам не нужно ловить SQLExceptions, поскольку Spring преобразует эти исключения в runtime exceptions;
- мы лучше интегрируемся в экосистему Spring, поскольку TransactionTemplate будет использовать TransactionManager
  под капотом, который в свою очередь будет использовать источник данных. Нам нет нужды беспокоиться о любых
  bean-нах, которые мы должны указать в конфигурации контекста Spring-а.

-----------------------------------------------------------------------------------------------------------------
*** Декларативном управлении транзакциями Spring (Declarative Transaction Management) при помощи XML ***

На этапе становления Spring-a конфигурация через XML была нормой для проектов Spring Framework. Мы могли
конфигурировать транзакции непосредственно в XML файле. На данном этапе развития экосистемы Spring-a, такой
стиль управления транзакциями редкость и его вытеснил гораздо более простой метод через аннотирование
при помощи @Transactional, однако он существовал и его нужно иметь в виду.

В качестве примера останавливаться на конфигурации XML, который можно использовать в качестве отправной точки,
чтобы углубиться в него - при необходимости (он взят официальной документации Spring-a):

*****************************************************************************************************************
<!-- транзакционный совет (advice) (что "происходит"; см. <aop:advisor/> бин ниже) -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- семантика транзакций... -->
        <tx:attributes>
            <!--все методы, начинающиеся с 'get', доступны только для чтения -->
            <tx:method name="get*" read-only="true"/>
            <!-- другие методы используют настройки транзакции по умолчанию (см. ниже) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
*****************************************************************************************************************

Мы определяем advice AOP (Aspect Oriented Programming, аспектно-ориентированное программирование) с помощью
приведенного выше блока XML, который затем можно применить к bean-у UserService следующим образом:

*****************************************************************************************************************
<aop:config>
    <aop:pointcut id="userServiceOperation" expression="execution(* x.y.service.UserService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="userServiceOperation"/>
</aop:config>

<bean id="userService" class="x.y.service.UserService"/>
*****************************************************************************************************************

Тогда наш bean UserService будет выглядеть следующим образом:

*****************************************************************************************************************
public class UserService {

    public Long registerUser(User user) {
        /*
        Выполняем SQL, который, например, вставляет пользователя
        в базу данных и извлекает авто-сгенерированный id
        */
      return id;
    }
}
*****************************************************************************************************************

С точки зрения кода Java, этот декларативный подход к транзакциям выглядит намного проще, чем программный подход.
Но он приводит к большому количеству сложного, многословного XML с конфигурациями указателей и советников (advisor).
Поэтому дальнейшая эволюция Spring-a дала нам аннотацию @Transactional.

-----------------------------------------------------------------------------------------------------------------
*** Декларативном управлении транзакциями Spring (Declarative Transaction Management) при помощи @Transactional ***

Современное управление транзакциями в Spring (осень 2023) выглядит так:

*****************************************************************************************************************
public class UserService {

    @Transactional
    public Long registerUser(User user) {
        /*
        Выполнить некоторый SQL, который, например, вставляет
        пользователя в БД и извлекает авто-сгенерированный id
        */
        userDao.save(user);
        return id;
    }
}
*****************************************************************************************************************

Вместо конфигурации через XML теперь нужно сделать две вещи:
- Убедитесь, что наша Configuration Spring сопровождена аннотацией @EnableTransactionManagement (в Spring boot
  это будет сделано автоматически).
- Убедитесь, что мы указали менеджер транзакций в нашей Configuration Spring (это необходимо сделать в любом
  случае).

Spring достаточно умный, чтобы явно обрабатывать транзакции для нас: любой публичный public метод bean, который
мы сопроводим аннотацией @Transactional, будет выполняться внутри транзакции БД (обратите внимание: есть
некоторые 'подводные камни' при работе с транзакциями в Spring, поскольку используется проксирование объектов
см. в DOC/AnnotationTransactional/ProxyHowToWorksIs.txt).

Итак, чтобы аннотация @Transactional заработала, всё, что вам нужно сделать, это следующее:

*****************************************************************************************************************
@Configuration
@EnableTransactionManagement
public class MySpringConfig {

    @Bean
    public PlatformTransactionManager txManager() {
        return yourTxManager; // подробнее об этом позже
    }

}
*****************************************************************************************************************

Теперь, вооружившись знаниями из примера транзакций в JDBC, приведённый выше, код @Transactional UserService
преобразуется (упрощенно) в следующий вид:

*****************************************************************************************************************
public class UserService {

    public Long registerUser(User user) {
        Connection connection = dataSource.getConnection(); // (1)
        try (connection) {
            connection.setAutoCommit(false); /* (1) */

            /*
            Выполнить некий SQL запрос, который, например, вставляет
            пользователя в БД и извлекает авто-сгенерированный идентификатор
            */
            userDao.save(user); /* (2) */

            connection.commit(); /* (1) */
        } catch (SQLException e) {
            connection.rollback(); /* (1) */
        }
    }
}
*****************************************************************************************************************

И снова:
1. - стандартное открытие и закрытие соединения JDBC. Это то, что @Transactional аннотация Spring делает для
     нас автоматически, без необходимости писать весь 'коммуникационный код' явно;
2. - наш собственный код, сохраняющий пользователя через DAO или другой класс;

Spring вставляет весь транзакционно-коммуникационный код для нас через прокси-объекты.

-----------------------------------------------------------------------------------------------------------------
*** Работа @Transactional через CGlib или JDK прокси ***

Spring не может переписать наш Java класс, как показано выше, чтобы вставить код подключения (если только мы не
используем продвинутые техники, такие как bytecode weaving).

Наш метод registerUser() действительно просто вызывает userDao.save(user), и нет способа изменить это на лету.

Но у Spring есть преимущество. По своей сути это IoC container (контейнер инверсии контроля). Он создаёт для нас
экземпляр UserService и обеспечивает авто-подключение этого UserService к любому другому bean-у, которому нужен
этот UserService.

Теперь, когда мы используем @Transactional над bean-ми, Spring использует маленькую хитрость. Он не просто
создает экземпляр объекта (instance) UserService, но и транзакционный прокси этого UserService.

Делается это методом под названием proxy-through-subclassing с помощью библиотеки Cglib см.:
https://github.com/cglib/cglib)
Существуют вариант построения прокси (через Dynamic JDK proxies), см.:
https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html

Принцип работы прокси в действии изображен на рисунке см. DOC/TransactionInSpring/ProxyObject.jpg

На рисунке видно, что у конкретного прокси есть следующие задачи:
- открытие и закрытие соединений/транзакций с базой данных;
- затем делегирование процессов настоящему UserService, тому, который мы написали;

Другие bean-ы, такие, как наш UserRestController, никогда не узнают, что они разговаривают с прокси, а не с
настоящим объектом.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!! ВОПРОС НА ВНИМАТЕЛЬНОСТЬ !!!
Есть следующий исходный код:

*****************************************************************************************************************
@Configuration
@EnableTransactionManagement
public static class MyAppConfig {

    @Bean
    public UserService userService() {
        return new UserService();
    }
}
*****************************************************************************************************************

Вопрос: Какой тип UserService автоматически сконструирует Spring, предполагая, что он помечен @Transactional на
        уровне класса или имеет ту же аннотацию на уровне метода внутри класса конфигурации.
Ответ: Spring здесь создаёт динамический CGLib-прокси класса UserService, который может открывать и закрывать
       транзакции БД. Ни мы (если не изучаем код в DEBUG режиме), ни один bean-н даже не заметит, что это не
       наш UserService, а прокси, обертывающий наш UserService.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

-----------------------------------------------------------------------------------------------------------------
*** Менеджер транзакций (например, PlatformTransactionManager) ***

Теперь не хватает только одной важной части информации, хотя мы уже несколько раз упоминали о ней. Наш UserService
проксируется налету, и прокси управляет транзакциями для нас. Но не сам прокси управляет всеми этими транзакционными
состояниями (открыть, зафиксировать, закрыть), прокси делегирует эту работу менеджеру транзакций.

Spring предлагает нам интерфейс PlatformTransactionManager / TransactionManager, который по умолчанию поставляется
с парой удобных реализаций. Одна из них - менеджер транзакций источника данных.

Он делает то же самое, что мы делали до сих пор для управления транзакциями, но сначала давайте рассмотрим
необходимую конфигурацию Spring:

*****************************************************************************************************************
@Bean
public DataSource dataSource() {
    return new MysqlDataSource(); /* (1) */
}

@Bean
public PlatformTransactionManager txManager() {
    return new DataSourceTransactionManager(dataSource()); /* (2) */
}
*****************************************************************************************************************

1 - Здесь мы создаём источник данных, специфичный для БД или для пула соединений.
    В данном примере используется MySQL.
2 - Здесь мы создаём свой менеджер транзакций, которому нужен источник данных, чтобы иметь возможность управлять
    транзакциями.

Всё просто. Все менеджеры транзакций имеют методы типа "doBegin" (для запуска транзакции) или "doCommit",
которые выглядят следующим образом (взято из исходного кода Spring с некоторым упрощением):

*****************************************************************************************************************
public class DataSourceTransactionManager implements PlatformTransactionManager {

    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        Connection newCon = obtainDataSource().getConnection();
        // ...
        con.setAutoCommit(false);
        // Да, вот так!
    }

    @Override
    protected void doCommit(DefaultTransactionStatus status) {
        // ...
        Connection connection = status.getTransaction().getConnectionHolder().getConnection();
        try {
            con.commit();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not commit JDBC transaction", ex);
        }
    }
}
*****************************************************************************************************************

Таким образом, менеджер транзакций источника данных использует при управлении транзакциями точно такой же код,
который мы видели в разделе JDBC.

Учитывая это, наш рисунок приведенный выше преобразуется в: DOC/TransactionInSpring/ImprovedProxyScheme.jpg

В итоге мы имеем следующее:
- если Spring обнаруживает аннотацию @Transactional над классом (bean-ом), он создаёт динамический прокси
  этого класса (bean-a);
- созданный прокси имеет доступ к менеджеру транзакций и будет просить его открывать и закрывать транзакции и
  соединения с БД;

Менеджер транзакций будет делать то, что мы делали при работе с 'голым' JDBC - управлять соединением в JDBC,
см. https://github.com/JcoderPaul/JDBC_Practice

-----------------------------------------------------------------------------------------------------------------
*** Физические и логические транзакции ***

Представим следующие два класса транзакций.

*****************************************************************************************************************
@Service
public class UserService {

    @Autowired
    private InvoiceService invoiceService;

    @Transactional
    public void invoice() {
        invoiceService.createPdf();
        // отправка счёта по электронной почте и т.д...
    }
}
*****************************************************************************************************************

*****************************************************************************************************************
@Service
public class InvoiceService {

    @Transactional
    public void createPdf() {
        // ...
    }
}
*****************************************************************************************************************

UserService имеет транзакционный метод invoice(). Который вызывает другой транзакционный метод, createPdf() на
InvoiceService.

Теперь, с точки зрения транзакций БД, это должна быть всего лишь одна транзакция.

Помните: getConnection().setAutocommit(false).commit()

Spring называет это физической транзакцией, хотя сначала это может показаться немного запутанным. Однако, со
стороны Spring происходит две логические транзакции:
- первая - в UserService,
- вторая - в InvoiceService.

Spring достаточно умный, чтобы знать, что оба метода помечены @Transacional и должны использовать в основе одну
и ту же физическую транзакцию БД.

Как изменится ситуация если чуть переписать InvoiceService:

*****************************************************************************************************************
@Service
public class InvoiceService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
*****************************************************************************************************************

Изменение режима распространения (propagation) на REQUIRES_NEW говорит Spring-у, что createPDF() должна
выполняться в собственной транзакции, независимо от любой другой, уже существующей транзакции.

Это означает, что наш код будет открывать два (физических) соединения/транзакции с базой данных, т.е. снова:
getConnection() x2. setAutoCommit(false) x2. commit() x2.

Spring теперь должен сделать так, чтобы две логические транзакции invoice()/createPdf() также отображались
как две разные физические транзакции базы данных.

Итак, подведем итоги:
- Физические транзакции: это наши фактические транзакции JDBC.
- Логические транзакции: это (потенциально вложенные) аннотированные @Transactional методы Spring.

Это подводит нас к более подробному рассмотрению режимов распространения.

-----------------------------------------------------------------------------------------------------------------
*** Propagation Levels (уровни деления, размножения) в @Transactional ***

Изучая исходный код Spring, мы найдем множество уровней или режимов деления, которые можно подключить к методу
@Transactional:
- @Transactional(propagation = Propagation.REQUIRED);
- @Transactional(propagation = Propagation.REQUIRES_NEW);
и т.д.

Полный перечень:
- REQUIRED - (значение по умолчанию) - если есть активная, то выполняется в ней, если нет, то создается новая
             транзакция (getConnection().setAutocommit(false).commit());
- SUPPORTS - если есть активная - то выполняется в ней, если нет - то выполняется нетранзакционно
             (не имеет отношения к JDBC);
- MANDATORY - если есть текущая активная транзакция - выполняется в ней, иначе выбрасывается исключение
              (не имеет отношения к JDBC);
- REQUIRES_NEW - всегда создается новая транзакция, если есть активная - то она приостанавливается
                 (getConnection().setAutocommit(false).commit());
- NOT_SUPPORTED - выполняется вне транзакции - если есть активная, она приостанавливается
                  (не имеет отношения к JDBC);
- NESTED - выполняется внутри вложенной транзакции, если есть активная, если нет активной - то аналогично
           REQUIRED (не имеет отношения к JDBC);
- NEVER - выполняется вне транзакции, если есть активная - выбрасывается исключение (не имеет отношения к JDBC);

Как можно видеть, большинство режимов разделения на самом деле не имеют ничего общего с работой БД или JDBC.
Основная часть режимов разделения транзакций определяется тем, как мы структурируем свою Spring программу и
как, когда и где Spring ожидает присутствия транзакций.

Посмотрим пример:

*****************************************************************************************************************
public class UserService {

     @Transactional(propagation = Propagation.MANDATORY)
     public void myMethod() {
        /* выполнить sql */
     }

}
*****************************************************************************************************************

В этом случае Spring будет ожидать, что транзакция уже будет открыта, когда мы вызовем myMethod() класса
UserService. Он не открывает её сам, вместо этого, если мы вызовем этот метод без предварительно существующей
транзакции, Spring выбросит исключение.

Помните об этом как о дополнительных нюансах для "логической обработки транзакций".

-----------------------------------------------------------------------------------------------------------------
*** @Transactional уровни изоляции ***

Если мы настроим аннотацию @Transactional следующим образом:

*****************************************************************************************************************
@Transactional(isolation = Isolation.REPEATABLE_READ)
*****************************************************************************************************************

Это будет переведено, как:

*****************************************************************************************************************
connection
    .setTransactionIsolation(
            Connection.TRANSACTION_REPEATABLE_READ
    );
*****************************************************************************************************************

Уровни изоляции базы данных, является сложной темой, и нам следует потратить некоторое время, чтобы
полностью разобраться в ней.
См. (RUS): https://github.com/JcoderPaul/Hibernate_Lessons/tree/master/Hibernate_part_8
См. (ENG): https://www.postgresql.org/docs/9.5/transaction-iso.html

!!! Внимание !!! Когда речь идет о переключении уровней изоляции во время транзакции, мы должны точно знать,
                 какой драйвере JDBC/БД используем, чтобы понять, какие сценарии тем поддерживаются, а какие нет.

-----------------------------------------------------------------------------------------------------------------
*** Использование @Transactional сo Spring boot или Spring MVC ***

До сих пор мы говорили только об обычном, базовом Spring. Но, в экосистеме Spring-a есть: Spring boot, Spring MVC.

В обоих фреймворках (а точнее: во всех фреймворках экосистемы Spring) мы всегда будем использовать аннотацию
@Transactional в сочетании с менеджером транзакций и аннотацией @EnableTransactionManager.

Единственное отличие Spring заключается в том, что он автоматически устанавливает аннотацию
@EnableTransactionManager и создает PlatformTransactionManager для нас - с помощью авто-конфигураций JDBC.

-----------------------------------------------------------------------------------------------------------------
*** Управление транзакциями Spring и JPA / Hibernate ***

Цель: синхронизация @Transactional от Spring и JPA / Hibernate

В какой-то момент мы захотим, чтобы наше Spring приложение интегрировалось с другой библиотекой БД, такой,
как Hibernate (популярная реализация JPA) и т.д. В качестве примера рассмотрим простой Hibernate (примечание:
не имеет значения, используем ли мы Hibernate напрямую, или Hibernate через JPA).

Перепишем UserService из предыдущей версии см. выше в Hibernate будет выглядеть следующим образом:

*****************************************************************************************************************
public class UserService {

    @Autowired
    private SessionFactory sessionFactory; /* (1) */

    public void registerUser(User user) {

        /* Открываем сессию */
        Session session = sessionFactory.openSession(); /* (2) */

        /* Откроем транзакцию, помним о setAutocommit(false)! */
        session.beginTransaction();

        /* Сохраним == вставим (save == insert) наш объект в БД */
        session.save(user);

        /* Коммитим транзакцию */
        session.getTransaction().commit();

        /* Закрываем сессию == и наше соединение с БД */
        session.close();
    }
}
*****************************************************************************************************************

1. - Это обычная, SessionFactory Hibernate, точка входа для всех запросов в Hibernate.
2. - Ручное управление сессиями (соединениями с базой данных) и транзакциями с помощью API Hibernate.
См. больше примеров и док. (RUS): https://github.com/JcoderPaul/Hibernate_Lessons/tree/master

Однако в приведённом выше коде есть одна огромная проблема:
- Hibernate не будет знать об аннотации @Transactional от Spring;
- @Transactional Spring не будет знать ничего о транзакциях Hibernate;

Но нам необходимо, чтобы Spring и Hibernate интегрировались без проблем, то есть знали о транзакциях друг друга.

Например, так:

*****************************************************************************************************************
@Service
public class UserService {

    @Autowired
    private SessionFactory sessionFactory; /* (1) */

    @Transactional
    public void registerUser(User user) {
        sessionFactory.getCurrentSession().save(user); /* (2) */
    }

}
*****************************************************************************************************************

1. - тот же SessionFactory, что и раньше (пример выше), но...;
2. - больше никакого ручного управления состоянием. Вместо этого getCurrentSession() и @Transactional
     синхронизируются;

И тут нам помогает...

-----------------------------------------------------------------------------------------------------------------
*** Использование HibernateTransactionManager ***

Существует очень простое решение этой проблемы интеграции:

Вместо использования DataSourcePlatformTransactionManager в конфигурации Spring, мы будем использовать
HibernateTransactionManager (при использовании обычного Hibernate) или JpaTransactionManager (при использовании
Hibernate через JPA).

Специализированный HibernateTransactionManager:
- обеспечит управление транзакциями через Hibernate, т.е. через SessionFactory;
- позволить Spring-у использовать ту же самую транзакцию в коде Spring, не относящуюся к Hibernate,
  т.е. использовать функционал @Transactional.

Схема взаимодействия объектов (обратите внимание, что поток между прокси и реальным сервисом является лишь
концептуально правильным и упрощенным) см. DOC/TransactionInSpring/HibernateTransactionManager.jpg

Для других интеграций или более глубокого понимания процесса см. все возможные реализации
PlatformTransactionManager, которые предлагается в Spring:
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html

Заключение:

К этому моменту мы должны иметь довольно хорошее представление о том, как управление транзакциями работает со
Spring Framework-ом и как оно применяется к другим библиотекам Spring, таким как Spring boot или Spring WebMVC.
Главным выводом должно быть то, что не имеет значения, какой фреймворк мы используем, ключевым моментом является
понимание основ работы JDBC.

Понимание этого (помните: getConnection().setAutocommit(false).commit()) позволит гораздо легче понять, что
произойдет позже в нашем 'сложном корпоративном' приложении.