### Кратко о том как работает proxy

Во многих фирмах, на собеседовании задают следующий вопрос:

Дан сервис:
```Java
	@Service
	public class ServiceTest{
	  @Transactional
	  public void test1{
	      test2();
	  }
	
	  @Transactional(propagation = Propagation.REQUIRES_NEW)
	  public void test2(){
	  }
	}
```

- Будет ли при вызове test2 из метода test1 создана новая транзакция?

Самый грамотный и полный ответ, который я встречал, был уже приведен в одной статье и звучать он должен примерно
так:

**«В связи с тем, что для поддержки транзакций через аннотации используется Spring AOP, в момент вызова test1()
на самом деле вызывается метод прокси объекта. Создается новая транзакция и далее происходит вызов test1() класса
ServiceTest. А когда из test1() вызовем test2(), обращения к прокси нет, вызывается уже сразу метод нашего класса
и, соответственно, никаких новых транзакций создаваться не будет».**

Но знаете, как это бывает, вроде и ответ правильный уже давно знаешь. И применяешь это знание регулярно. А вдруг
раз… и неожиданно задумаешься:

**«Подождите-ка, ведь если мы используем Spring AOP, то там могут создаваться прокси и через JDK. Очевидно, что если
для создания оберток используется JDK dynamic proxy, то это утверждение должно быть верным. Ведь в этом случае
объекты создаются на основе интерфейсов. Такой объект будет полностью соответствовать паттерну Proxy и все выглядит
вполне логично. Но ведь могут создаваться прокси и через CGLIB и тогда использует другой подход, он создает классы
наследники. А тут уже и начинают закрадываться сомнения, будет ли поведение идентичным. Еще интереснее всё
становиться, когда мы решаем использовать внешние инструменты для связывания: CTW (compile-time weaving) или
LTW (load-time weaving) подключили. И что ответ приведенный выше всегда будет верен?»**

В этой же статье рассмотрим только классический и самый простой случай для лучшего понимания,
что происходит дальше. Под капотом наш bean будет иметь примерно следующий вид:

```Java
	public class Proxy{
		private ServiceTest targetService;
	
	  public void test1{
	    //код начала транзакции
	    // ...
	      targetService.test1();
	    //код конца транзакции
	    // ...
	  }
	
	  public void test2(){
	    //код начала транзакции
	    // ...
	      targetService.test2();
	    //код конца транзакции
	    // ...
	  }
	}
```

Это прекрасно иллюстрирует рисунок см. 

![CallerTargetProxy](./DOC/TransactionalOnSpring/CallerTargetProxy.jpg)

Из рисунка следует, что при вызове метода test1 код, управляющий транзакциями, вызван не будет и новая транзакция
не откроется. Аналогичное поведение - когда вызывается метод родительского класса.
