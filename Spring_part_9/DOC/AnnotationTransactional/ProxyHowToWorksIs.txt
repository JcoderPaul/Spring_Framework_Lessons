****** Кратко о том как работает proxy ******

Во многих фирмах, на собеседовании задают следующий вопрос:

Дан сервис:
******************************************************************************************************************
@Service
public class ServiceTest{
  @Transactional
  public void test1{
      test2();
  }

  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public void test2(){
  }
}
******************************************************************************************************************

- Будет ли при вызове test2 из метода test1 создана новая транзакция?

Самый грамотный и полный ответ, который я встречал, был уже приведен в одной статье и звучать он должен примерно
так:

«В связи с тем, что для поддержки транзакций через аннотации используется Spring AOP, в момент вызова test1()
на самом деле вызывается метод прокси объекта. Создается новая транзакция и далее происходит вызов test1() класса
ServiceTest. А когда из test1() вызовем test2(), обращения к прокси нет, вызывается уже сразу метод нашего класса
и, соответственно, никаких новых транзакций создаваться не будет».

Но знаете, как это бывает, вроде и ответ правильный уже давно знаешь. И применяешь это знание регулярно. А вдруг
раз… и неожиданно задумаешься:

«Подождите-ка, ведь если мы используем Spring AOP, то там могут создаваться прокси и через JDK. Очевидно, что если
для создания оберток используется JDK dynamic proxy, то это утверждение должно быть верным. Ведь в этом случае
объекты создаются на основе интерфейсов. Такой объект будет полностью соответствовать паттерну Proxy и все выглядит
вполне логично. Но ведь могут создаваться прокси и через CGLIB и тогда использует другой подход, он создает классы
наследники. А тут уже и начинают закрадываться сомнения, будет ли поведение идентичным. Еще интереснее всё
становиться, когда мы решаем использовать внешние инструменты для связывания: CTW (compile-time weaving) или
LTW (load-time weaving) подключили. И что ответ приведенный выше всегда будет верен?»..

В этой же статье рассмотрим только классический и самый простой случай для лучшего понимания,
что происходит дальше. Под капотом наш bean будет иметь примерно следующий вид:

******************************************************************************************************************
public class Proxy{
	private ServiceTest targetService;

  public void test1{
    //код начала транзакции
    // ...
      targetService.test1();
    //код конца транзакции
    // ...
  }

  public void test2(){
    //код начала транзакции
    // ...
      targetService.test2();
    //код конца транзакции
    // ...
  }
}
******************************************************************************************************************

Это прекрасно иллюстрирует рисунок см. DOC/TransactionalOnSpring/CallerTargetProxy.jpg

Из рисунка следует, что при вызове метода test1 код, управляющий транзакциями, вызван не будет и новая транзакция
не откроется. Аналогичное поведение - когда вызывается метод родительского класса.