См. исх (ENG): https://phauer.com/2015/restful-api-design-best-practices/
************************************************************************************************************************

****** RESTful API Design. Best Practices in a Nutshell. ******

Разработка API HTTP и RESTful может быть сложной задачей, поскольку не существует официального и обязательного стандарта.
По сути, существует множество способов реализации API, но некоторые из них доказали свою эффективность на практике и
получили широкое распространение. В этом посте рассматриваются лучшие практики создания API HTTP и RESTful. Мы поговорим
о структуре URL-адресов, методах HTTP, создании и обновлении ресурсов, проектировании связей, форматах полезной нагрузки,
нумерации страниц, управлении версиями и многом другом.

________________________________________________________________________________________________________________________
*** Используйте два URL-адреса для каждого ресурса ***

Один URL-адрес для коллекции и один для одного ресурса см. рис. DOC/API_Design/JPG/http-address-for-api.jpg:

************************************************************************************************************************
# URL that represents a collection of resources
/employees
# URL that represents a single resource
/employees/56
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Используйте последовательно существительные во множественном числе ***

Лучше делать так:

************************************************************************************************************************
/employees
/employees/21
************************************************************************************************************************

А вот так, делать не рекомендуется:

************************************************************************************************************************
/employee
/employee/21
************************************************************************************************************************

Действительно, это дело вкуса, но чаще встречается форма множественного числа. Более того, это более интуитивно понятно,
особенно при использовании GET для URL-адреса коллекции ( GET /employees - возврат нескольких сотрудников). Но самое
главное: избегайте смешивания существительных во множественном и единственном числе, что может сбить с толку и привести
к ошибкам.

________________________________________________________________________________________________________________________
*** Используйте существительные вместо глаголов для ресурсов ***

Это позволит вам упростить API и сократить количество URL-адресов.

НЕ НАДО так делать:

************************************************************************************************************************
/getAllEmployees
/getAllExternalEmployees
/createEmployee
/updateEmployee
************************************************************************************************************************

Вместо этого ЛУЧШЕ выразить необходимое действие с помощью доступных методов HTTP на небольшом наборе URL-адресов.
См. следующий раздел.

________________________________________________________________________________________________________________________
****** HTTP-методы ******

*** Используйте методы HTTP для работы с вашими ресурсами ***

************************************************************************************************************************
GET /employees
GET /employees?state=external
POST /employees
PUT /employees/56
************************************************************************************************************************

Используйте URL-адреса, чтобы указать ресурсы, с которыми вы хотите работать. Используйте методы HTTP, чтобы указать,
что делать с этим ресурсом. С помощью пяти HTTP-методов GET, POST, PUT, PATCH и DELETE вы можете обеспечить
функциональность CRUD (создание, чтение, обновление, удаление) и многое другое.

Read - Читать : используйте GET для чтения ресурсов.
Create - Создать : используйте POST или PUT для создания новых ресурсов.
Update - Обновить : используйте PUT и PATCH для обновления существующих ресурсов.
Delete - Удалить : используйте DELETE для удаления существующих ресурсов.

________________________________________________________________________________________________________________________
*** Понимание семантики методов HTTP ***

Методы HTTP являются идемпотентными, когда мы можем безопасно выполнять запрос снова и снова, и все запросы приводят к
одному и тому же состоянию.

________________________________________________________________________________________________________________________
Идемпотентность («равносильность» от лат. idem «тот же самый» + potens «способный») — свойство объекта или операции при
повторном применении операции к объекту давать тот же результат, что и при первом. Термин предложил американский математик
Бенджамин Пирс (англ. Benjamin Peirce) в статьях 1870-х годов.

Идемпотентная операция в информатике — действие, многократное повторение которого эквивалентно однократному.

Примером такой операции могут служить GET-запросы в протоколе HTTP. По спецификации, сервер должен возвращать идентичные
ответы на идентичные GET-запросы (при условии, что ресурс не изменился). Это позволяет корректно кэшировать эти ответы,
снижая нагрузку на сеть.
________________________________________________________________________________________________________________________

- GET:
    - Идемпотентный.
    - Только для чтения. GET никогда не меняет состояние ресурса на стороне сервера. Оно не должно иметь побочных
      эффектов.
    - Следовательно, ответ можно безопасно кэшировать.
    - Примеры:
        GET /employees - Показывает всех сотрудников
        GET /employees/1 - Показывает данные о сотруднике 1

- PUT:
    - Идемпотентный!
    - Может использоваться как для создания, так и для обновления.
    - Обычно используется для обновления (полные обновления).
    - Пример:
        PUT /employees/1 - обновляет сотрудника 1 (редко: создает сотрудника 1)
    - Чтобы использовать PUT для создания, клиенту необходимо заранее знать весь URL-адрес (включая идентификатор). Это
      редкость, поскольку сервер обычно генерирует идентификатор. Поэтому PUT для создания обычно используется, когда
      имеется только один элемент и URL-адрес однозначен.
    - Пример:
        PUT /employees/1/avatar - создает или обновляет аватар сотрудника 1. Для каждого сотрудника существует только
                                  один аватар.
    - Всегда включайте в запрос всю полезную нагрузку. Т.е. все или ничего. PUT не предназначен для частичного обновления
      (см. ниже PATCH).

- POST:
    - Не идемпотент!
    - Используется для создания.
    - Пример:
        POST /employees - создает нового сотрудника. Новый URL-адрес доставляется обратно клиенту в Location заголовке
                          (например Location: /employees/12). Множественные запросы POST /employees приводят к появлению
                          множества новых сотрудников (поэтому POST не идемпотентен).

- PATCH:
    - Идемпотент.
    - Используется для частичных обновлений.
    - Пример:
        PATCH /employees/1 — обновляет сотрудника 1 полями, содержащимися в полезных данных. Остальные поля сотрудника 1
        не изменяются.

- DELETE:
    - Идемпотент.
    - Используется для удаления.
    - Пример:
        DELETE /employees/1 - удалить сотрудника 1.

________________________________________________________________________________________________________________________
*** POST по URL-адресу коллекции ресурсов для создания нового ресурса ***

Как может выглядеть клиент-серверное взаимодействие для создания нового ресурса? См. рис. DOC/API_Design/JPG/POST.jpg
Желательно использовать POST для создания нового ресурса:
1. Клиент отправляет POST-запрос на URL-адрес коллекции ресурсов /employees. Тело HTTP содержит атрибуты нового
   ресурса «Paul».
2. Веб-сервис RESTful генерирует идентификатор нового сотрудника, создает сотрудника в своей внутренней модели и
   отправляет ответ клиенту. Этот ответ содержит код состояния 201 (Создано) и Location HTTP-заголовок, указывающий
   URL-адрес, по которому доступен созданный ресурс.

________________________________________________________________________________________________________________________
*** PUT на единый URL-адрес ресурса для обновления ресурса ***

Используйте PUT для обновления существующего ресурса см. рис DOC/API_Design/JPG/PUT.jpg:
1. Клиент отправляет запрос PUT на один URL-адрес ресурса /employee/21. Тело HTTP запроса PUT содержит все поля
   сотрудника, и каждое поле будет обновлено на стороне сервера.
2. Служба REST обновляет name данные status сотрудника с идентификатором 21 и подтверждает изменения с помощью кода
   состояния HTTP 200.

________________________________________________________________________________________________________________________
*** Используйте PATCH для частичных обновлений ресурса ***

PUT НЕ предназначен для частичных обновлений. PUT следует использовать только для полной замены ресурса. Отправка всех
полей каждый раз (хотя вы хотите обновить только одно поле) может привести к случайной перезаписи в случае параллельных
обновлений. Более того, реализация проверки сложна, поскольку необходимо поддерживать оба варианта использования:
создание (некоторые поля не должны быть null) и обновление (null значения для обозначения полей, которые не должны
обновляться) одновременно.

!!! Поэтому не используйте PUT и отправляйте только те поля, которые необходимо обновить. Отсутствующие поля в запросе
PUT следует рассматривать как null значения и очищать поля базы данных или вызывать ошибки проверки !!!

Вместо этого используйте PATCH для частичных обновлений. Отправляйте только те поля, которые необходимо обновить. Таким
образом, полезная нагрузка запроса становится довольно простой, параллельные обновления различных полей не переопределяют
несвязанные поля, проверка становится проще, семантика значений null однозначна (как для PUT, так и для PATCH), и вы
экономите полосу пропускания.

Например, следующий запрос PATCH обновляет только поле status, но не файл name см. рис DOC/API_Design/JPG/PATCH.jpg. Еще
раз - "Используйте PATCH и отправляйте только те поля, которые хотите обновить!"

************************************************************************************************************************
Примечание по реализации: помимо описанного подхода «просто отправьте то, что хотите обновить» (который также
                          рекомендуется JSON:API - https://jsonapi.org/format/#crud-updating ), существует
                          JSON-PATCH - https://jsonpatch.com/. Это формат полезной нагрузки для запросов PATCH,
                          описывающий последовательность изменений, которые следует выполнить с ресурсом.
                          Однако во многих случаях его сложно реализовать, и он является излишним.

                          Для получения более подробной информации ознакомьтесь с публикацией:
                          «PUT против PATCH против JSON-PATCH » - https://philsturgeon.com/put-vs-patch-vs-json-patch/
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Оберните фактические данные в data - поле  ***

GET /employees - возвращает список объектов в поле data:

************************************************************************************************************************
{
  "data": [
    { "id": 1, "name": "Larry" }
    , { "id": 2, "name": "Peter" }
  ]
}
************************************************************************************************************************

GET /employees/1 - возвращает один объект в поле data:

************************************************************************************************************************
{
  "data": {
    "id": 1,
    "name": "Larry"
  }
}
************************************************************************************************************************

Полезная нагрузка запросов PUT, POST и PATCH также должна содержать поле data с реальным объектом.

Преимущества:
- Осталось место для добавления метаданных (например, для нумерации страниц, ссылок, предупреждений об устаревании,
  сообщений об ошибках).
- Последовательность или консистентность - согласованность данных друг с другом, целостность данных.
- Совместимость со стандартом JSON:API - https://jsonapi.org/.

________________________________________________________________________________________________________________________
*** Используйте строку запроса (?) для необязательных и сложных параметров ***

НЕ НАДО ТАК ДЕЛАТЬ:

************************************************************************************************************************
GET /employees
GET /externalEmployees
GET /internalEmployees
GET /internalAndSeniorEmployees
************************************************************************************************************************

Сохраняйте URL-адреса простыми и небольшими. Выберите один базовый URL-адрес для своего ресурса и придерживайтесь его.
Переместите сложность или дополнительные параметры в строку запроса, вот так:

************************************************************************************************************************
GET /employees?state=internal&title=senior
GET /employees?id=1,2
************************************************************************************************************************

Способ фильтрации JSON:API:

************************************************************************************************************************
GET /employees?filter[state]=internal&filter[title]=senior
GET /employees?filter[id]=1,2
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Используйте коды состояния HTTP ***

Веб-служба RESTful должна ответить на запрос клиента подходящим кодом ответа о состоянии HTTP.

2xx - success - успех - все заработало нормально.
4xx - client error - ошибка клиента - если клиент сделал что-то не так (например, клиент отправляет неверный запрос
                                      или он не авторизован)
5xx - server error - ошибка сервера – сбои на стороне сервера (ошибки при попытке обработки запроса, такие как сбои базы
                                      данных, недоступные зависимые службы, ошибки программирования или состояния,
                                      которые не должны возникать)

*** Рассмотрим доступные коды состояния HTTP ***

Однако имейте в виду, что использование всех из них может сбить с толку пользователей вашего API. Держите набор
используемых кодов состояния HTTP небольшим. Обычно используются следующие коды:

- 2xx: Success:
    200 - ОК;
    201 - Создано;
- 3xx: Redirect:
    301 - Переехал навсегда;
    304 - Не изменено;
- 4xx: Client Error:
    400 - Неверный запрос;
    401 - Несанкционированный;
    403 - Запрещено;
    404 - Не найдено;
    410 - Ушел, пропал;
- 5xx: ошибка сервера:
    500 - внутренняя ошибка сервера;

Не злоупотребляйте 404. Постарайтесь быть более точным. Если ресурс доступен, но пользователю не разрешено его
просматривать, верните 403 Forbidden. Если ресурс когда-то существовал, но теперь был удален или деактивирован,
используйте 410 Gone.

________________________________________________________________________________________________________________________
*** Предоставляйте полезные сообщения об ошибках ***

Помимо соответствующего кода состояния, вы должны предоставить полезное и подробное описание ошибки в теле вашего
HTTP-ответа. Вот пример:

Запрос:

************************************************************************************************************************
GET /employees?state=super
************************************************************************************************************************

Ответ:

************************************************************************************************************************
// 400 Bad Request
{
  "errors": [
    {
      "status": 400,
      "detail": "Invalid state. Valid values are 'internal' or 'external'",
      "code": 352,
      "links": {
        "about": "http://www.domain.com/rest/errorcode/352"
      }
    }
  ]
}
************************************************************************************************************************

Предлагаемая структура полезных данных ошибок основана на стандарте JSON:API - https://jsonapi.org/format/#errors.

________________________________________________________________________________________________________________________
*** Предоставьте ссылки для навигации по вашему API (HATEOAS) ***

В идеале вы не позволяете своим клиентам создавать URL-адреса для использования вашего REST API. Давайте рассмотрим
пример. Клиент хочет получить доступ к отчетам о зарплате сотрудника. Поэтому он должен знать, что может получить доступ
к отчетам о зарплате, добавив параметр запроса salaryStatements к URL-адресу сотрудника,
(например: /employees/21/salaryStatements). Эта конкатенация строк подвержена ошибкам, хрупка и сложна в обслуживании.
Если вы измените способ доступа к выписке о зарплате в своем REST API (например, используя теперь “salary-statements”
или “paySlips”), все клиенты сломаются.

Лучше предоставить в ответе ссылки, по которым клиент сможет перейти.
Например, ответ на GET /employees может выглядеть так:

************************************************************************************************************************
{
  "data": [
    {
      "id":1,
      "name":"Paul",
      "links": [
        {
          "salary": "http://www.domain.com/employees/1/salaryStatements"
        }
      ]
    }
  ]
}
************************************************************************************************************************

Если клиент полагается исключительно на ссылки для получения отчета о зарплате, он не сломается, если вы измените свой
API, поскольку клиент всегда будет получать действительный URL-адрес (при условии, что вы обновляете ссылку в случае
изменения URL-адреса). Еще одним преимуществом является то, что ваш API становится более информативным, и клиентам не
нужно часто искать документацию.

________________________________________________________________________________________________________________________
*** Проектируйте взаимоотношения соответствующим образом ***

Предположим, что у каждого employee есть manager и несколько teamMembers. В основном существует три распространенных
варианта проектирования отношений внутри API:
- ссылки;
- загрузка неопубликованных приложений (Sideloading - сторонняя загрузка);
- встраивание;

Все они действительны, и правильный выбор зависит от варианта использования. По сути, вам следует проектировать
отношения в зависимости от схемы доступа клиента, а также допустимого объема запроса и размера полезной нагрузки.

*** 1. Ссылки:

************************************************************************************************************************
{
  "data": [
    {
      "id": 1,
      "name": "Larry",
      "relationships": {
        "manager": "http://www.domain.com/employees/1/manager",
        "teamMembers": [
          "http://www.domain.com/employees/12",
          "http://www.domain.com/employees/13"
        ]
        //or "teamMembers": "http://www.domain.com/employees/1/teamMembers"
      }
    }
  ]
}
************************************************************************************************************************

- Небольшой размер полезной нагрузки. Хорошо, если клиенту не нужно каждый раз и одновременно и manager и teamManager.
- Много запросов. Плохо, если эти данные нужны практически каждому клиенту. Может потребоваться множество дополнительных
  запросов; в худшем случае для каждого сотрудника. И это умножается на все отношения (manager и teamMembers и т. д.),
  которые есть у сотрудника.
- Клиенту необходимо объединить данные, чтобы получить общую картину.

*** 2. Неопубликованная загрузка

Мы можем сослаться на связь с внешним ключом и поместить упомянутые объекты также в полезные данные, но в специальное
поле included. Этот подход также называется «Составные документы»:

************************************************************************************************************************
{
  "data": [
    {
      "id": 1,
      "name": "Larry",
      "relationships": {
        "manager":  5 ,
        "teamMembers": [ 12, 13 ]
      }
    }
  ],
  "included": {
    "manager": {
      "id": 5,
      "name": "Kevin"
    },
    "teamMembers": [
      { "id": 12, "name": "Albert" }
      , { "id": 13, "name": "Tom" }
    ]
  }
}
************************************************************************************************************************

Клиент также может управлять загруженными неопубликованными объектами с помощью параметра запроса, например:
GET /employees?include=manager,teamMembers. И тогда:

- Мы обходимся одной просьбой.
- Индивидуальный размер полезной нагрузки. Никакого дублирования (например, вы назначаете менеджера только один раз,
  даже если на него ссылаются многие сотрудники).
- Клиенту по-прежнему приходится объединять данные для разрешения взаимосвязей, что может быть очень обременительным.

*** 3. Встраивание

************************************************************************************************************************
{
  "data": [
    {
      "id": 1,
      "name": "Larry",
      "manager": {
        "id": 5,
        "name": "Kevin"
      },
      "teamMembers": [
        { "id": 12, "name": "Albert" }
        , { "id": 13, "name": "Tom" }
      ]
    }
  ]
}
************************************************************************************************************************

- Максимально удобно для клиента. Можно напрямую следить за отношениями, чтобы получить фактические данные.
- Отношения могут быть нагружены зря, если клиенту это не нужно.
- Увеличенный размер полезной нагрузки и дублирование. Объекты, на которые ссылаются, могут быть внедрены несколько раз.

________________________________________________________________________________________________________________________
*** Используйте CamelCase для имен атрибутов ***

Используйте CamelCase для идентификаторов атрибутов:

************************************************************************************************************************
{ "yearOfBirth": 1982 }
************************************************************************************************************************

Не используйте подчеркивания (year_of_birth) или заглавные буквы (YearOfBirth). Часто ваш веб-сервис RESTful будет
использоваться клиентом, написанным на JavaScript. Обычно клиент преобразует ответ JSON в объект JavaScript (путем
вызова var person = JSON.parse(response)) и вызывает его атрибуты. Поэтому рекомендуется придерживаться соглашения
JavaScript, которое делает код JavaScript более читабельным и интуитивно понятным.

НЕ ДЕЛАЙТЕ ТАК:
************************************************************************************************************************
person.year_of_birth // нарушает соглашение JavaScript
person.YearOfBirth // предлагается метод конструктора
************************************************************************************************************************

ДЕЛАЙТЕ ТОЛЬКО ТАК:

************************************************************************************************************************
person.yearOfBirth
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Используйте глаголы для операций ***

Иногда ответ на вызов API не требует ресурсов (для таких, как вычисление, преобразование или преобразование).
Пример:

************************************************************************************************************************
//Чтение
GET /translate?from=de_DE&to=en_US&text=Hallo
GET /calculate?para2=23&para2=432

//Запустить операцию, которая меняет состояние на стороне сервера
POST /restartServer

// Ничего
POST /banUserFromChannel
{ "user": "123", "channel": "serious-chat-channel" }
************************************************************************************************************************

В этом случае никакие ресурсы не задействованы. Вместо этого сервер выполняет операцию и возвращает результат клиенту.
Следовательно, вам следует использовать глаголы вместо существительных в своем URL-адресе, чтобы четко отличать операции
(API в стиле RPC) от конечных точек REST (ресурсов для моделирования домена).

Создание этих API-интерфейсов в стиле RPC вместо API-интерфейсов REST подходит для операций. Обычно это проще и интуитивно
понятнее, чем пытаться использовать RESTful для операций (например, PATCH /serverс {"restart": true}). Как правило, REST
удобен для взаимодействия с моделями предметной области, а RPC — для операций. Для получения более подробной информации
ознакомьтесь с разделом:
«Понимание RPC и REST для HTTP API» - https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/

________________________________________________________________________________________________________________________
*** Обеспечить нумерацию страниц ***

Возвращать сразу все ресурсы базы данных почти никогда не является хорошей идеей. Следовательно, вам следует обеспечить
механизм нумерации страниц. Два популярных подхода:
- Пагинация на основе смещения.
- Пагинация на основе набора ключей, также известная как токен продолжения или курсор (рекомендуется).

*** 1. Пагинация на основе смещения.

Действительно простой подход — использовать параметры offset и limit, которые хорошо известны из баз данных.

************************************************************************************************************************
/employees?offset=30&limit=15       # returns the employees 30 to 45
************************************************************************************************************************

Если клиент опускает параметр, вам следует использовать значения по умолчанию (например, offset=0 и limit=100). Никогда
не возвращайте все ресурсы. Если извлечение обходится дороже, следует уменьшить лимит.

************************************************************************************************************************
/employees                          # returns the employees 0 to 100
************************************************************************************************************************

Вы можете предоставить ссылки для перехода на следующую или предыдущую страницу. Просто создайте URL-адреса с
соответствующим смещением и ограничением.

************************************************************************************************************************
GET /employees?offset=20&limit=10
************************************************************************************************************************

на выходе:

************************************************************************************************************************
{
  "pagination": {
    "offset": 20,
    "limit": 10,
    "total": 3465,
  },
  "data": [
    //...
  ],
  "links": {
    "next": "http://www.domain.com/employees?offset=30&limit=10",
    "prev": "http://www.domain.com/employees?offset=10&limit=10"
  }
}
************************************************************************************************************************

*** 2. Пагинация на основе набора ключей (также известная как токен продолжения, курсор).

Представленная нумерация страниц на основе смещения проста в реализации, но имеет серьезные недостатки. Они медленны
(предложение SQL OFFSET становится очень медленным для больших чисел) и небезопасны (легко пропустить элементы, когда
изменения происходят во время нумерации страниц).

Вот почему лучше использовать индексированный столбец. Предположим, что у наших сотрудников есть индексированный столбец
data_created, и ресурс коллекции /employees?pageSize=100 возвращает 100 самых старых сотрудников, отсортированных по
этому столбцу. Теперь клиенту нужно только взять dateCreated метку времени последнего сотрудника и использовать параметр
запроса createdSince, чтобы продолжить с этого момента.

************************************************************************************************************************
GET /employees?pageSize=100
# Клиент получает 100 самых старых сотрудников, отсортированных по `data_created`
# Последний сотрудник на странице имеет поле dataCreated с номером 1504224000000 (= 1 сентября 2017 г., 12:00:00 AM)

GET /employees?pageSize=100&createdSince=1504224000000
# Клиент получает следующие 100 сотрудников с 1504224000000.
# Последний сотрудник страницы был создан на 1506816000000. И так далее...
************************************************************************************************************************

Это уже решает многие недостатки нумерации страниц со смещением, но все равно не идеально и не очень удобно для клиента.

Лучше создать так называемый токен продолжения, добавив к дате дополнительную информацию (например, идентификатор),
чтобы повысить надежность и эффективность. Более того, вы должны предоставить специальное поле в полезных данных для
этого токена, чтобы клиенту не приходилось выяснять это, просматривая элементы. Вы даже можете пойти дальше и
предоставить next ссылку.

И тогда, GET /employees?pageSize=100 возвращается:

************************************************************************************************************************
{
  "pagination": {
    "continuationToken": "1504224000000_10",
  },
  "data": [
    // ...
    // last element:
    { "id": 10, "dateCreated": 1504224000000 }
  ],
  "links": {
    "next": "http://www.domain.com/employees?pageSize=100&continue=1504224000000_10"
  }
}
************************************************************************************************************************

Ссылка next делает API действительно RESTful, поскольку клиент может просматривать коллекцию, просто следуя этим ссылкам
(HATEOAS). Нет необходимости создавать URL-адреса вручную. Более того, вы можете просто изменить структуру URL-адресов,
не нарушая работу клиентов (эволюционируемость).

Для получения более подробной информации ознакомьтесь со специальными публикациями о пагинации веб-API:
- Разбивка на страницы веб-API с токеном продолжения Timestamp_Offset_Checksum. Предлагаемый подход больше не
  рекомендуется, но сообщение прекрасно вводит всю тему (включая разбиение на страницы на основе смещения) см. -
  https://phauer.com/2017/web-api-pagination-continuation-token/
- Разбивка на страницы веб-API с помощью токена продолжения Timestamp_ID. Я рекомендую использовать этот подход.
  Он также содержит обзор существующих подходов к нумерации страниц на основе набора ключей см. -
  https://phauer.com/2018/web-api-pagination-timestamp-id-continuation-token/

________________________________________________________________________________________________________________________
*** Проверьте JSON:API ***

Вам следует хотя бы взглянуть на JSON:API. Это стандартный формат для полезных данных JSON и ресурсов службы HTTP (тип
MIME: application/vnd.api+json). Лично я не следую всем рекомендациям, так как некоторые из них кажутся мне слишком
формализованными и излишними. На мой взгляд, достигнутая гибкость часто не требуется, но усложняет реализацию, не
принося пользы. Но это дело вкуса, и следовать стандартам – это, по сути, хорошая идея. Я использую это как вдохновение
и выбираю те элементы, которые имеют для меня смысл. Не стесняйтесь принимать решения по поводу JSON:API.

*** Обеспечьте возможность развития API ***

*** Избегайте критических изменений ***

В идеале API REST (как и любой API) должны быть стабильными. По сути, критических изменений (например, изменения всего
формата полезных данных или схемы URL-адресов) не должно происходить. Но как мы можем развивать наш API, не нарушая
работу клиентов?

И тогда:

- Внесите обратно совместимые изменения. Добавление полей не представляет проблемы (при условии, что клиенты терпимы).
- Дублирование и устаревание. Чтобы изменить существующее поле (переименовать или изменить структуру), вы можете
  добавить новое рядом со старым полем и объявить старое устаревшим в документации. Через некоторое время вы сможете
  удалить старое поле.
- Используйте Hypermedia и HATEOAS. Пока клиент API использует ссылки в ответе для навигации по API (и не создает
  URL-адреса вручную), вы можете безопасно изменять URL-адреса, не нарушая работу клиентов.
- Создавайте новые ресурсы с новыми именами. Если новые бизнес-требования приводят к совершенно новой модели предметной
  области и рабочим процессам, вы можете создать новые ресурсы. Зачастую это довольно интуитивно понятно, поскольку
  модель домена в любом случае имеет новое имя (полученное из названия компании).

  Пример: служба проката теперь также арендует велосипеды и сегвеи. Так что старая концепция car ресурса /cars больше
  не работает. Представлена новая модель предметной области vehicleс новым ресурсом /vehicles. Он предоставляется
  вместе со старым /cars ресурсом.

________________________________________________________________________________________________________________________
*** Храните бизнес-логику на стороне сервера ***

Не позволяйте вашему сервису стать уровнем доступа к данным дампа, который обеспечивает функциональность CRUD, напрямую
раскрывая вашу модель базы данных (низкоуровневый API). Это создает высокую степень связи.

- Бизнес-логика переносится на клиента и часто реплицируется между клиентом и сервером (просто подумайте о проверке).
  Мы должны синхронизировать оба процесса.
- Часто клиент связан с моделью базы данных сервера.

Нам следует избегать создания API-интерфейсов доступа к дампу данных, поскольку они приводят к высокой степени связи
между сервером и клиентами, поскольку рабочие процессы бизнеса распределяются между клиентом и сервером. Это, в свою
очередь, делает вероятным, что новые бизнес-требования потребуют изменения как клиента, так и сервера, а также нарушения
API. Таким образом, API/система не так уж и развита.

Поэтому нам следует создавать API высокого уровня/на основе рабочих процессов вместо API низкого уровня.

Пример: не предоставляйте простой сервис CRUD для объектов заказа в базе данных. Не требуйте, чтобы клиенты знали, что
для отмены заказа клиент должен поместить заказ в общий /order/1 ресурс с определенной полезной нагрузкой отмены
(отражающей модель базы данных). Это приводит к высокой связанности (бизнес-логика и знание предметной области на
стороне клиента; открытая модель базы данных). Вместо этого предоставьте выделенный ресурс /order/1/cancelation и
добавьте ссылку на него в полезные данные ресурса заказа. Клиент может перейти по URL-адресу отмены и отправить
адаптированную полезную нагрузку отмены. Бизнес-логика для сопоставления этой полезной нагрузки с моделью базы
данных выполняется на сервере. Более того, сервер может легко изменить URL-адрес, не нарушая работу клиента, поскольку
клиент просто переходит по ссылкам. Кроме того, логика принятия решения о том, можно ли отменить заказ или нет, теперь
находится на сервере: если отмена возможна, сервер добавляет ссылку на ресурс отмены в полезные данные заказа. Таким
образом, клиенту нужно только проверить наличие ссылок отмены (например, чтобы узнать, следует ли ему нарисовать кнопку
отмены). Поэтому мы перенесли знания предметной области с клиента обратно на сервер. Изменения условий отмены можно
легко применить, всего лишь коснувшись сервера, что, в свою очередь, делает систему развиваемой. Никаких изменений API
не требуется.

Если вам хочется больше узнать об этой теме, я рекомендую YouTube доклад Оливера Гирке:
«REST за пределами очевидного - проектирование API для постоянно развивающихся систем» -
https://www.youtube.com/watch?v=mQkf85S9UoQ&t=1s.

________________________________________________________________________________________________________________________
*** Рассмотрите возможность управления версиями API ***

Тем не менее, вы можете оказаться в ситуации, когда описанные выше подходы не работают, и вам действительно придется
предоставлять разные версии вашего API. Управление версиями позволяет вам выпускать несовместимые и критические
изменения вашего API в новой версии, не нарушая при этом работу клиентов. Они могут продолжать использовать старую
версию. Клиенты могут перейти на новую версию со своей скоростью.

Эта тема активно обсуждается в обществе. Вы должны принять во внимание, что в конечном итоге вам придется создавать и
поддерживать (!) разные версии API в течение длительного времени, что обходится дорого.

Если вы создаете внутренние API, вы, скорее всего, знаете всех своих клиентов. Таким образом, выполнение критических
изменений снова может быть вариантом. Но это потребует большего взаимодействия и скоординированного развертывания.

Тем не менее, вот два наиболее популярных подхода к управлению версиями:
- Управление версиями через URL-адреса:/v1/;
- Управление версиями через Accept HTTP-заголовок: Accept: application/vnd.myapi.v1+json (согласование контента);

*** 1. Управление версиями через URL-адреса

Просто укажите номер версии вашего API в URL-адресе каждого ресурса.

************************************************************************************************************************
/v1/employees
************************************************************************************************************************

Плюсы:
- Чрезвычайно просто для разработчиков API.
- Чрезвычайно просто для клиентов API.
- URL-адреса можно копировать и вставлять.

Минусы:
- Не RESTful.
- Взлом URL-адресов. Клиенты должны поддерживать и обновлять URL-адреса.

Строго говоря, этот подход не является RESTful, поскольку URL-адреса никогда не должны меняться. Это предотвращает
легкую эволюцию. Размещение версии в URL-адресе однажды приведет к поломке API, и вашим клиентам придется исправлять
URL-адреса. Вопрос в том, сколько усилий потребуется клиентам для обновления URL-адресов? Если ответ «немного», то
управление версиями URL-адресов может подойти.

Благодаря своей простоте управление версиями URL-адресов очень популярно и широко используется такими компаниями,
как Facebook, Twitter, Google/YouTube, Bing, Dropbox, Tumblr и Disqus.

*** 2. Управление версиями через Accept HTTP-заголовок (согласование контента)

Более RESTful способ управления версиями — использовать согласование содержимого через Accept заголовок HTTP-запроса.

************************************************************************************************************************
GET /employees
Accept: application/vnd.myapi.v2+json
************************************************************************************************************************

В этом случае клиент запрашивает версию 2 ресурса /employees. Таким образом, мы рассматриваем разные версии API как
разные представления ресурса /employees, что вполне соответствует RESTful. Вы можете сделать v2 необязательным и
использовать последнюю версию по умолчанию, когда клиент запрашивает только с помощью Accept: application/vnd.myapi+json.
Но будьте честны и предупредите его, что его приложение может сломаться в будущем, если он не закрепит версию.

Плюсы:
- URL-адреса остаются прежними
- Считается RESTFul
- HATEOAS-дружественный

Минусы:
- Немного сложнее в использовании. Клиенты должны обратить внимание на заголовки.
- URL-адреса больше нельзя копировать и вставлять.

________________________________________________________________________________________________________________________
*** Личные мысли автора статьи о версионности ***

При создании нового API попробуйте использовать его без управления версиями URL. Особенно внутренние API могут вообще
никогда не нуждаться в реальной версии 2 для существующих ресурсов. Вы можете согласиться с подходами, описанными в
разделе:
«Избегайте критических изменений» - https://phauer.com/2015/restful-api-design-best-practices/#avoid-breaking-changes.

Если вам, наконец, действительно нужна новая версия существующего ресурса, вы все равно можете пойти на согласование
контента и использовать заголовок Accept. Но в целом лучше создать API, который в первую очередь снизит вероятность
критических изменений (например, создав API высокого уровня/потока процессов и сохранив бизнес-логику на сервере).

Ведутся бесконечные дискуссии о том, как правильно версионировать API, что такое RESTful, а что нет. Люди очень
расстраиваются. Я предпочитаю быть прагматичным. Для меня совершенно нормально, если вас не волнует теория REST,
когда дело доходит до управления версиями (и вы используете управление версиями URL), если это работает для вас,
ваших клиентов и вы осведомлены о предстоящих расходах на обслуживание.

«Совет»: говорите о «Веб-API» или «HTTP API» вместо «REST API», чтобы честно говорить о соответствии REST и успокоить
фанатиков REST. ;-)

________________________________________________________________________________________________________________________
*** Рекомендуемые материалы ***
- Фил Стерджен «Создавайте API, которые вы не будете ненавидеть» - https://www.amazon.co.uk/dp/0692232699/
- Лучшие практики тестирования RESTful-сервисов на Java -
  https://phauer.com/2016/testing-restful-services-java-best-practices/
- JSON: Стандарт API - https://jsonapi.org/
- Фил Стерджен «Ответ на REST — это новый SOAP (объяснение путаницы с REST)» -
  https://philsturgeon.com/rest-confusion-explained/
- Фил Стерджен «Понимание RPC и REST для HTTP API» -
  https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis/
________________________________________________________________________________________________________________________