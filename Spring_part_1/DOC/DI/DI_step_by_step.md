### Внедрение зависимости (DI)

Представьте себе очень простую зависимость между двумя классами: класс «Автомобиль» (Car)
зависит от класса «Двигатель» (CarEngine) см. 

![DOC/DI/Car_to_Engine.png](./DOC/DI/Car_to_Engine.png).

Однако, существует мнение, что данную связь стоит программировать с помощью интерфейса
см. 

![DOC/DI/Car_to_Engine_with_Interface.png](./DOC/DI/Car_to_Engine_with_Interface.png)

И тогда код будет выглядеть, например, так:

        public interface Engine {
            boolean isStart();
        }
        
        class CarEngine implements Engine {
        
            @Override
            public boolean isStart() {
                return true;
            }
        }
        
        class Car {
        
            public void start() {
                Engine engine = new CarEngine();
                if (engine.isStart()) {
                    System.out.println("Start!");
                }
            }
        }

Но, в итоге, данный код будет соответствовать несколько иной диаграмме классов
см. DOC/DI/Engine_Create_in_Car.png

Чтобы изолировать класс Car, недостаточно ввести интерфейс Engine. В коде класса Car также
должно быть невозможным создание нового экземпляра класса CarEngine, он туда должен
поставляться готовым:

        class Car {
        
            private Engine engine;
        
            public Car(Engine engine) {
                this.engine = engine;
            }
        
            public void start() {
                if (engine.isStart()) {
                    System.out.println("Start!");
                }
            }
        }

Теперь с помощью этого дизайна можно создавать экземпляры класса Car с внедряемыми
двигателями Engine:

        Car car = new Car(new CarEngine());

Концепция Dependency Injection (DI) состоит в том, чтобы перенести ответственность за создание
экземпляра объекта из тела метода за пределы класса и передать уже созданный экземпляр объекта.

Теперь принципа DI немного понятен. На базе этой идеи (архитектурного подхода, паттерна) появились
DI фреймворки. Варианты внедрения одних объектов в другие:

---
### Внедрение зависимостей (инъекция) во время выполнения кода и во время его компиляции

Поскольку инъекция во время выполнения увеличивает время, необходимое для запуска приложения,
оно подходит не для всех типов приложений. Она, например, не подходит для тех приложений, которые
запускаются много раз, и работают в течение короткого периода времени. В этом случае более
актуальным является внедрение зависимостей во время компиляции. Так, например, обстоит дело с
Android-приложениями.

---
### Внедрения зависимостей с помощью конструктора, сеттера и поля класса

Пример с классом Car выше описывал внедрение зависимости через конструктор класса. Однако, это
не единственный способ внедрения зависимостей. Альтернативы включают в себя:

- внедрение зависимости через сеттер.

        Car car = new Car();
        car.setEngine(new CarEngine());

Этот подход не является хорошей идеей, так как нет причин, по которым зависимость должна меняться
во время жизненного цикла внедряемого объекта.

- внедрение зависимости через поле класса.

        class Car {
            private Engine engine = new CarEngine();
            ...
        }

Этот способ еще хуже, потому что он требует не только рефлексии, но и обхода проверок
безопасности (если они имеются). Несмотря на то, что некоторые DI-фреймворки, а также
некоторые фреймворки для тестирования допускают описанные выше способы внедрения, их
следует избегать любой ценой.

---
### Явное и неявное связывание

Некоторые фреймворки допускают неявную инъекцию зависимостей, также называемую autowiring.
Чтобы выполнить инъекцию, такие фреймворки будут искать в контексте подходящего кандидата.
И потерпят неудачу, если не найдут ни одного подходящего класса или более одного.

Другие фреймворки допускают явное внедрение зависимостей: в этом случае разработчику необходимо
сконфигурировать инъекцию путем явной привязки отношения между объектом и зависимостью.

---
### Способы конфигурации

Каждый фреймворк предоставляет один или несколько способов своей конфигурации. Как было показано
выше, применение DI не требует каких-либо фреймворков. Однако мы взялись за изучение Spring, который
позволяет использовать много различных способов конфигурации:

- XML
- Аннотации
- Классы конфигурации Java
- Groovy скрипты
- Kotlin, через Bean definition DSL

Хотя DI не может быть ограничен рамками одного Spring, последний также не может быть сведен
только лишь к внедрению зависимостей. Spring предлагает большой набор дополнительной
функциональности.

Инъекция зависимостей сделает наш код более модульным, что способствует более простому его
обновлению, а также лучшему тестированию. Использование DI архитектуры позволит:

— Запрограммировать инъекцию или настроить инфраструктуру для этого;
— Выбрать среду выполнения или временную структуру DI для компиляции;
— Выбрать легкий DI контейнер, или полноценный, с набором доп. функций
  (Spring, Context and Dependency Injection, Google Guice, PicoContainer, Dagger 2);

И еще раз о DI фреймворках:

- Spring framework предоставляет:
    - - Cтандарт для серверных Java приложений;
    - - Инъекция во время выполнения;
    - - Внедрение зависимости через конструктор, сеттер и поле;
    - - Описанные выше способы конфигурации;
    - - Явное и неявное (autowiring) связывание;

- Dagger 2 предоставляет:
    - - Де-факто стандарт для Android;
    - - Инъекция во время компиляции;
    - - Внедрение зависимости через конструктор, поле или метод с акцентом на первые два способа;
    - - Конфигурация при помощи аннотаций и внешних классов;
    - - Неявное связывание;

---
- Исходник: https://topjava.ru/blog/back-to-basics-dependency-injection
- Еще немного о DI: https://github.com/JcoderPaul/Junit5_Tests/tree/master/Junit5_lesson_7/DOC
