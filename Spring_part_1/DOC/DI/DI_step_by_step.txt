****** Внедрение зависимости (DI) ******

Представьте себе очень простую зависимость между двумя классами: класс «Автомобиль» (Car)
зависит от класса «Двигатель» (CarEngine) см. DOC/DI/Car_to_Engine.png.

Однако, существует мнение, что данную связь стоит программировать с помощью интерфейса
см. DOC/DI/Car_to_Engine_with_Interface.png

И тогда код будет выглядеть, например, так:

********************************************************************************************
public interface Engine {
    boolean isStart();
}

class CarEngine implements Engine {

    @Override
    public boolean isStart() {
        return true;
    }
}

class Car {

    public void start() {
        Engine engine = new CarEngine();
        if (engine.isStart()) {
            System.out.println("Start!");
        }
    }
}
********************************************************************************************

Но, в итоге, данный код будет соответствовать несколько иной диаграмме классов
см. DOC/DI/Engine_Create_in_Car.png

Чтобы изолировать класс Car, недостаточно ввести интерфейс Engine. В коде класса Car также
должно быть невозможным создание нового экземпляра класса CarEngine, он туда должен
поставляться готовым:

********************************************************************************************
class Car {

    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        if (engine.isStart()) {
            System.out.println("Start!");
        }
    }
}
********************************************************************************************

Теперь с помощью этого дизайна можно создавать экземпляры класса Car с внедряемыми
двигателями Engine:

********************************************************************************************
Car car = new Car(new CarEngine());
********************************************************************************************

Концепция Dependency Injection (DI) состоит в том, чтобы перенести ответственность за создание
экземпляра объекта из тела метода за пределы класса и передать уже созданный экземпляр объекта.

Теперь принципа DI немного понятен. На базе этой идеи (архитектурного подхода, паттерна) появились
DI фреймворки. Варианты внедрения одних объектов в другие:

*** Внедрение зависимостей (инъекция) во время выполнения кода и во время его компиляции ***

Поскольку инъекция во время выполнения увеличивает время, необходимое для запуска приложения,
оно подходит не для всех типов приложений. Она, например, не подходит для тех приложений, которые
запускаются много раз, и работают в течение короткого периода времени. В этом случае более
актуальным является внедрение зависимостей во время компиляции. Так, например, обстоит дело с
Android-приложениями.

*** Внедрения зависимостей с помощью конструктора, сеттера и поля класса ***

Пример с классом Car выше описывал внедрение зависимости через конструктор класса. Однако, это
не единственный способ внедрения зависимостей. Альтернативы включают в себя:

- внедрение зависимости через сеттер.

********************************************************************************************
Car car = new Car();
car.setEngine(new CarEngine());
********************************************************************************************

Этот подход не является хорошей идеей, так как нет причин, по которым зависимость должна меняться
во время жизненного цикла внедряемого объекта.

- внедрение зависимости через поле класса.

********************************************************************************************
class Car {
    private Engine engine = new CarEngine();
    ...
}
********************************************************************************************

Этот способ еще хуже, потому что он требует не только рефлексии, но и обхода проверок
безопасности (если они имеются). Несмотря на то, что некоторые DI-фреймворки, а также
некоторые фреймворки для тестирования допускают описанные выше способы внедрения, их
следует избегать любой ценой.

*** Явное и неявное связывание ***

Некоторые фреймворки допускают неявную инъекцию зависимостей, также называемую autowiring.
Чтобы выполнить инъекцию, такие фреймворки будут искать в контексте подходящего кандидата.
И потерпят неудачу, если не найдут ни одного подходящего класса или более одного.

Другие фреймворки допускают явное внедрение зависимостей: в этом случае разработчику необходимо
сконфигурировать инъекцию путем явной привязки отношения между объектом и зависимостью.

*** Способы конфигурации ***

Каждый фреймворк предоставляет один или несколько способов своей конфигурации. Как было показано
выше, применение DI не требует каких-либо фреймворков. Однако мы взялись за изучение Spring, который
позволяет использовать много различных способов конфигурации:
- XML
- Аннотации
- Классы конфигурации Java
- Groovy скрипты
- Kotlin, через Bean definition DSL

Хотя DI не может быть ограничен рамками одного Spring, последний также не может быть сведен
только лишь к внедрению зависимостей. Spring предлагает большой набор дополнительной
функциональности.

Инъекция зависимостей сделает наш код более модульным, что способствует более простому его
обновлению, а также лучшему тестированию. Использование DI архитектуры позволит:
— Запрограммировать инъекцию или настроить инфраструктуру для этого;
— Выбрать среду выполнения или временную структуру DI для компиляции;
— Выбрать легкий DI контейнер, или полноценный, с набором доп. функций
  (Spring, Context and Dependency Injection, Google Guice, PicoContainer, Dagger 2);

И еще раз о DI фреймворках:
- Spring framework предоставляет:
    Cтандарт для серверных Java приложений;
    Инъекция во время выполнения;
    Внедрение зависимости через конструктор, сеттер и поле;
    Описанные выше способы конфигурации;
    Явное и неявное (autowiring) связывание;

- Dagger 2 предоставляет:
    Де-факто стандарт для Android;
    Инъекция во время компиляции;
    Внедрение зависимости через конструктор, поле или метод с акцентом на первые два способа;
    Конфигурация при помощи аннотаций и внешних классов;
    Неявное связывание;

Исходник: https://topjava.ru/blog/back-to-basics-dependency-injection
Еще немного о DI: https://github.com/JcoderPaul/Junit5_Tests/tree/master/Junit5_lesson_7/DOC