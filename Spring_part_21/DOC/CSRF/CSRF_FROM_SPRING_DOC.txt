См. исходник (ENG):
https://docs.spring.io/spring-security/reference/features/exploits/csrf.html
________________________________________________________________________________________________________________________
****** Cross Site Request Forgery (CSRF) - Подделка межсайтовых запросов (CSRF) ******

Spring обеспечивает комплексную поддержку для защиты от атак межсайтовой подделки запросов (CSRF) -
https://en.wikipedia.org/wiki/Cross-site_request_forgery.

В следующих разделах мы исследуем:
- Что такое CSRF-атака?
- Защита от атак CSRF
- Соображения CSRF

!!! Внимание !!! В этой части документации обсуждается общая тема защиты CSRF. См. соответствующие разделы для получения
                 конкретной информации о защите CSRF для приложений на основе сервлетов и WebFlux:
                    - https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf ;
                    - https://docs.spring.io/spring-security/reference/reactive/exploits/csrf.html#webflux-csrf ;

________________________________________________________________________________________________________________________
*** Что такое CSRF-атака? ***

Лучший способ понять атаку CSRF — рассмотреть конкретный пример. Предположим, что на веб-сайте вашего банка есть форма,
позволяющая перевести деньги от текущего пользователя, вошедшего в систему, на другой банковский счет. Например, форма
перевода может выглядеть так (Форма перевода хорошего банка):

************************************************************************************************************************
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
************************************************************************************************************************

Соответствующий HTTP-запрос может выглядеть так (Передача HTTP-запроса):

************************************************************************************************************************
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
************************************************************************************************************************

Теперь представьте, что вы авторизуетесь на веб-сайте своего банка, а затем, не выходя из системы, посетите ЗЛОЙ
веб-сайт. Веб-сайт злоумышленника содержит HTML-страницу следующей формы (Форма передачи злого хакера):

************************************************************************************************************************
<form method="post"
	action="https://bank.example.com/transfer">
<input type="hidden"
	name="amount" value="100.00"/>
<input type="hidden"
	name="routingNumber" value="evilsRoutingNumber"/>
<input type="hidden"
	name="account" 	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
************************************************************************************************************************

Вам нравится выигрывать деньги, поэтому вы нажимаете кнопку «Отправить». При этом вы непреднамеренно перевели 100
долларов злоумышленнику. Это происходит потому, что, хотя злонамеренный веб-сайт не может видеть ваши файлы cookie,
файлы cookie, связанные с вашим банком, по-прежнему отправляются вместе с запросом.

Хуже того, весь этот процесс можно было бы автоматизировать с помощью JavaScript. Это значит, что вам даже не нужно
было нажимать на кнопку. Более того, это может так же легко произойти при посещении честного сайта, ставшего жертвой
XSS-атаки - https://owasp.org/www-community/attacks/xss/.

Так как же нам защитить наших пользователей от таких атак?

________________________________________________________________________________________________________________________
*** Защита от атак CSRF ***

Причина, по которой возможна CSRF-атака, заключается в том, что HTTP-запрос с веб-сайта жертвы и запрос с веб-сайта
злоумышленника абсолютно одинаковы. Это означает, что невозможно отклонить запросы, поступающие с вредоносного
веб-сайта, и разрешить только запросы, поступающие с веб-сайта банка. Чтобы защититься от CSRF-атак, нам необходимо
убедиться, что в запросе есть что-то, что злонамеренный сайт не может предоставить, чтобы мы могли различать два
запроса.

Spring предоставляет два механизма защиты от атак CSRF:
- Шаблон токена синхронизатора;
- Указание атрибута SameSite в файле cookie сеанса;

!!! Внимание !!! Обе защиты требуют, чтобы безопасные методы были доступны только для чтения -
                 https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1.

________________________________________________________________________________________________________________________
*** Безопасные методы должны быть доступны только для чтения ***

Чтобы любая защита от CSRF работала, приложение должно гарантировать, что «безопасные» методы HTTP доступны только для
чтения. Это означает, что запросы с методами HTTP GET, HEAD, OPTIONS и TRACE не должны изменять состояние приложения.

________________________________________________________________________________________________________________________
*** Шаблон токена синхронизатора ***

Преобладающим и наиболее комплексным способом защиты от CSRF-атак является использование шаблона токена Synchronizer -
https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern.
Это решение призвано гарантировать, что каждый HTTP-запрос требует, в дополнение к нашему файлу cookie сеанса, в
HTTP-запросе присутствовать безопасное случайное сгенерированное значение, называемое токеном CSRF.

При отправке HTTP-запроса сервер должен найти ожидаемый токен CSRF и сравнить его с фактическим токеном CSRF в
HTTP-запросе. Если значения не совпадают, HTTP-запрос должен быть отклонен.

Ключом к этой работе является то, что реальный токен CSRF должен находиться в части HTTP-запроса, которая не включается
браузером автоматически. Например, требование фактического токена CSRF в параметре HTTP или заголовке HTTP защитит от
атак CSRF. Требование фактического токена CSRF в файле cookie не работает, поскольку файлы cookie автоматически
включаются в HTTP-запрос браузера.

Мы можем смягчить ожидания и требовать только действительный токен CSRF для каждого HTTP-запроса, обновляющего состояние
приложения. Чтобы это работало, наше приложение должно гарантировать, что безопасные методы HTTP доступны только для
чтения. Это повышает удобство использования, поскольку мы хотим разрешить ссылки на наш сайт с внешних сайтов.

Кроме того, мы не хотим включать случайный токен в HTTP GET, поскольку это может привести к утечке токенов.

Подумайте, как изменится наш пример, если мы будем использовать шаблон токена синхронизатора. Предположим, что
фактический токен CSRF должен находиться в параметре HTTP с именем _csrf. Форма перевода нашего приложения будет
выглядеть так (Форма токена синхронизатора):

************************************************************************************************************************
<form method="post"
	action="/transfer">
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="hidden"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
************************************************************************************************************************

Форма теперь содержит скрытый ввод со значением токена CSRF. Внешние сайты не могут прочитать токен CSRF, поскольку та
же политика происхождения гарантирует, что злонамеренный сайт не сможет прочитать ответ. Соответствующий HTTP-запрос
на перевод денег будет выглядеть так (Запрос токена синхронизатора):

************************************************************************************************************************
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
************************************************************************************************************************

Вы заметите, что HTTP-запрос теперь содержит _csrf параметр с безопасным случайным значением. Злоумышленный веб-сайт не
сможет предоставить правильное значение параметра _csrf (которое должно быть явно указано на злонамеренном веб-сайте),
и передача завершится неудачей, когда сервер сравнит фактический токен CSRF с ожидаемым токеном CSRF.

________________________________________________________________________________________________________________________
*** Атрибут SameSite ***

Новый способ защиты от атак CSRF — указать атрибут SameSite в файлах cookie. Сервер может указать SameSite атрибут при
настройке файла cookie, чтобы указать, что файл cookie не должен отправляться с внешних сайтов см.
https://datatracker.ietf.org/doc/html/draft-west-first-party-cookies

!!! Внимание!!! Spring Security не контролирует напрямую создание файла cookie сеанса, поэтому не обеспечивает поддержку
                атрибута SameSite. Spring Session - https://spring.io/projects/spring-session, обеспечивает поддержку
                атрибута SameSite в приложениях на основе сервлетов. Spring Framework CookieWebSessionIdResolver -
                https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html
                обеспечивает встроенную поддержку атрибута SameSite в приложениях на основе WebFlux.

Пример заголовка ответа HTTP с SameSite атрибутом может выглядеть так (HTTP-ответ SameSite):

************************************************************************************************************************
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
************************************************************************************************************************

Допустимые значения атрибута SameSite:
- Strict: если указано, любой запрос, поступающий с того же сайта, включает файл cookie. В противном случае файл cookie
  не включается в HTTP-запрос.
- Lax: если указано, файлы cookie отправляются при поступлении с того же сайта или когда запрос поступает от навигации
  верхнего уровня, и метод доступен только для чтения. В противном случае файл cookie не включается в HTTP-запрос.

Рассмотрим, как можно защитить наш пример SameSite с помощью атрибута. Банковское приложение может защитить от CSRF,
указав SameSite атрибут в файле cookie сеанса.

Если SameSite атрибут установлен в нашем сеансовом файле cookie, браузер продолжает отправлять файл JSESSIONID cookie с
запросами, поступающими с банковского веб-сайта. Однако браузер больше не отправляет файл JSESSIONID cookie с запросом
на передачу, исходящим от злонамеренного веб-сайта. Поскольку сеанс больше не присутствует в запросе на передачу,
поступающем от вредоносного веб-сайта, приложение защищено от атаки CSRF.

Есть несколько важных моментов, которые следует учитывать при использовании SameSite атрибута для защиты от атак CSRF.

Установка SameSite атрибута Strict обеспечивает более надежную защиту, но может запутать пользователей. Рассмотрим
пользователя, который остается авторизованным на сайте социальной сети, расположенном по адресу social.example.com.
Пользователь получает электронное письмо на адрес email.example.org, содержащее ссылку на сайт социальной сети. Если
пользователь нажимает на ссылку, он по праву ожидает, что пройдет аутентификацию на сайте социальной сети. Однако, если
SameSite атрибут равен Strict, файл cookie не будет отправлен, и поэтому пользователь не будет аутентифицирован.

!!! Внимание !!! Мы могли бы улучшить защиту и удобство использования SameSite защиты от атак CSRF, внедрив gh-7537 -
                 https://github.com/spring-projects/spring-security/issues/7537.

Еще одно очевидное соображение заключается в том, что для того, чтобы SameSite атрибут защищал пользователей, браузер
должен поддерживать этот SameSite атрибут. Большинство современных браузеров поддерживают атрибут SameSite -
https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#browser_compatibility.

Однако, старые браузеры, которые все еще используются, могут этого не сделать.

По этой причине мы обычно рекомендуем использовать SameSite атрибут в качестве глубокоэшелонированной защиты, а не
единственной защиты от атак CSRF.

________________________________________________________________________________________________________________________
*** Когда использовать защиту CSRF ***

Когда следует использовать защиту CSRF? Мы рекомендуем использовать защиту CSRF для любого запроса, который может быть
обработан браузером обычными пользователями. Если вы создаете службу, которая используется только клиентами, не
являющимися браузерами, вы, вероятно, захотите отключить защиту CSRF.

________________________________________________________________________________________________________________________
*** Защита CSRF и JSON ***

Распространенный вопрос: «Нужно ли мне защищать запросы JSON, сделанные JavaScript-ом?» Короткий ответ: это зависит.
Однако, вы должны быть очень осторожны, поскольку существуют эксплойты CSRF, которые могут повлиять на запросы JSON.
Например, злоумышленник может создать CSRF с JSON, используя следующую форму (CSRF с формой JSON):

************************************************************************************************************************
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
	<input name='{"amount":100,
	              "routingNumber":"evilsRoutingNumber",
	              "account":"evilsAccountNumber",
	              "ignore_me":"' value='test"}'
	              type='hidden'>
	<input type="submit" value="Win Money!"/>
</form>
************************************************************************************************************************

Это создает следующую структуру JSON (CSRF с запросом JSON):

************************************************************************************************************************
{ "amount": 100,
  "routingNumber": "evilsRoutingNumber",
  "account": "evilsAccountNumber",
  "ignore_me": "=test"
}
************************************************************************************************************************

Если бы приложение не проверяло заголовок Content-Type, оно было бы подвержено этому эксплойту. В зависимости от
настройки приложение Spring MVC, которое проверяет Content-Type, все равно может быть использовано путем обновления
суффикса URL-адреса, чтобы он заканчивался на *.json, как показано ниже (CSRF с формой JSON Spring MVC):

************************************************************************************************************************
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
	<input name='{"amount":100,
	              "routingNumber":"evilsRoutingNumber",
	              "account":"evilsAccountNumber",
	              "ignore_me":"' value='test"}'
	              type='hidden'>
	<input type="submit" value="Win Money!"/>
</form>
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** CSRF и браузерные приложения без сохранения состояния ***

Что, если мое приложение stateless? Это не обязательно означает, что вы защищены. Фактически, если пользователю не нужно
выполнять какие-либо действия в веб-браузере для данного запроса, он, вероятно, все еще уязвим для атак CSRF. Например,
рассмотрим приложение, которое использует специальный файл cookie, содержащий все состояние для аутентификации (вместо
JSESSIONID). При атаке CSRF вместе с запросом отправляется пользовательский файл cookie точно так же, как файл cookie
JSESSIONID был отправлен в нашем предыдущем примере. Это приложение уязвимо для атак CSRF!

Приложения, использующие базовую аутентификацию, также уязвимы для атак CSRF. Приложение уязвимо, поскольку браузер
автоматически включает имя пользователя и пароль во все запросы точно так же, как файл cookie JSESSIONID был отправлен
в нашем предыдущем примере.

________________________________________________________________________________________________________________________
*** Соображения по поводу CSRF ***

При реализации защиты от атак CSRF следует учитывать несколько особенностей.

________________________________________________________________________________________________________________________
*** Вход в систему - Logging In ***

Чтобы защититься от подделки запросов на вход, HTTP-запрос на вход должен быть защищен от атак CSRF. Защита от подделки
запросов на вход необходима для того, чтобы злоумышленник не смог прочитать конфиденциальную информацию жертвы. Атака
осуществляется следующим образом:
1. - Злоумышленник выполняет вход в систему CSRF с учетными данными злонамеренного пользователя (т.е. себя). Жертва
     теперь аутентифицирована как злонамеренный пользователь.
2. - Затем злоумышленник обманом заставляет жертву посетить взломанный веб-сайт и ввести конфиденциальную информацию.
3. - Информация связана с учетной записью злоумышленника, поэтому злоумышленник может войти в систему со своими учетными
     данными и просмотреть конфиденциальную информацию жертвы.

Возможная сложность в обеспечении защиты HTTP-запросов входа в систему от атак CSRF заключается в том, что у
пользователя может возникнуть тайм-аут сеанса, из-за которого запрос будет отклонен. Тайм-аут сеанса удивляет
пользователей, которые не ожидают, что для входа в систему потребуется сеанс. Для получения дополнительной информации
см. CSRF и тайм-ауты сеанса.

________________________________________________________________________________________________________________________
*** Выход из системы - Logging Out ***

Чтобы защититься от подделки запросов на выход из системы, HTTP-запрос выхода из системы должен быть защищен от атак
CSRF. Защита от подделки запросов на выход необходима для того, чтобы злоумышленник не смог прочитать конфиденциальную
информацию жертвы. Подробности об атаке смотрите в этой записи блога.

Возможная сложность в обеспечении защиты HTTP-запросов выхода из системы от атак CSRF заключается в том, что у
пользователя может возникнуть тайм-аут сеанса, из-за которого запрос будет отклонен. Тайм-аут сеанса удивляет
пользователей, которые не ожидают выхода из сеанса. Дополнительные сведения см. в разделе CSRF и таймауты сеансов.

________________________________________________________________________________________________________________________
*** CSRF и тайм-ауты сеанса ***

Чаще всего ожидаемый токен CSRF сохраняется в сеансе. Это означает, что по истечении срока действия сеанса сервер не
находит ожидаемый токен CSRF и отклоняет HTTP-запрос. Существует несколько вариантов (каждый из которых имеет свои
недостатки) решения тайм-аутов:
- Лучший способ сократить время ожидания — использовать JavaScript для запроса токена CSRF при отправке формы. Затем
  форма обновляется с помощью токена CSRF и отправляется.
- Другой вариант — использовать JavaScript, который сообщит пользователю, что его сеанс скоро истечет. Пользователь
  может нажать кнопку, чтобы продолжить и обновить сеанс.
- Наконец, ожидаемый токен CSRF может быть сохранен в файле cookie. Это позволяет ожидаемому токену CSRF пережить сеанс.

Кто-то может спросить, почему ожидаемый токен CSRF по умолчанию не сохраняется в файле cookie. Это связано с тем, что
известны эксплойты, в которых заголовки (например, для указания файлов cookie) могут быть установлены другим доменом.
По этой же причине Ruby on Rails больше не пропускает проверки CSRF при наличии заголовка X-Requested-With.

Подробную информацию о том, как выполнить эксплойт, можно найти в этой теме на webappsec.org -
https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html.

Еще одним недостатком является то, что, удалив состояние (то есть таймаут), вы теряете возможность принудительно сделать
токен недействительным, если он скомпрометирован.

________________________________________________________________________________________________________________________
*** Multipart (загрузка файла) ***

Защита составных запросов (загрузка файлов) от атак CSRF приводит к проблеме курицы или яйца. Чтобы предотвратить атаку
CSRF, необходимо прочитать тело HTTP-запроса для получения фактического токена CSRF. Однако чтение тела означает, что
файл загружен, а это означает, что внешний сайт может загрузить файл.

Существует два варианта использования защиты CSRF с multipart/form-data:
- Поместите токен CSRF в тело
- Поместите токен CSRF в URL-адрес.

Каждый вариант имеет свои компромиссы.

!!! Внимание !!! Прежде чем интегрировать защиту CSRF Spring Security с многочастной загрузкой файлов, вы должны сначала
                 убедиться, что вы можете загружать файлы без защиты CSRF. Дополнительную информацию об использовании
                 составных форм в Spring см. в разделе 1.1.11. Раздел Multipart Resolver -
                 https://docs.spring.io/spring-framework/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart
                 справочника Spring и MultipartFilter Javadoc -
                 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html

________________________________________________________________________________________________________________________
*** Поместите токен CSRF в тело ***

Первый вариант — включить действительный токен CSRF в тело запроса. Помещая токен CSRF в тело, тело считывается перед
выполнением авторизации. Это означает, что любой может разместить временные файлы на вашем сервере. Однако только
авторизованные пользователи могут отправить файл, который обрабатывается вашим приложением. В общем, это рекомендуемый
подход, поскольку загрузка временных файлов не должна оказывать незначительное влияние на большинство серверов.

________________________________________________________________________________________________________________________
*** Включить токен CSRF в URL-адрес ***

Если разрешение неавторизованным пользователям загружать временные файлы неприемлемо, альтернативой является включение
ожидаемого токена CSRF в качестве параметра запроса в атрибут действия формы. Недостатком этого подхода является
возможность утечки параметров запроса. В более общем плане считается лучшей практикой размещать конфиденциальные
данные внутри тела или заголовков, чтобы исключить их утечку.

Дополнительную информацию можно найти в RFC 2616, раздел 15.1.3 «Кодирование конфиденциальной информации в URI».

________________________________________________________________________________________________________________________
*** HiddenHttpMethodFilter ***

Некоторые приложения могут использовать параметр формы для переопределения метода HTTP. Например, следующая форма может
рассматривать метод HTTP как delete, а не как post (Форма скрытого HTTP-метода CSRF):

************************************************************************************************************************
<form action="/process" method="post">
	<!-- ... -->
	<input type="hidden" name="_method" value="delete"/>
</form>
************************************************************************************************************************

Переопределение метода HTTP происходит в фильтре. Этот фильтр должен быть установлен до поддержки Spring Security.

Обратите внимание, что переопределение происходит только для post, поэтому вряд ли это вызовет какие-либо реальные
проблемы. Тем не менее по-прежнему рекомендуется размещать его перед фильтрами Spring Security.