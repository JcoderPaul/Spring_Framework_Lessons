См. исходник (ENG):
https://www.baeldung.com/csrf-stateless-rest-api
________________________________________________________________________________________________________________________
****** CSRF с REST API без сохранения состояния ******

В нашей предыдущей статье - https://www.baeldung.com/csrf-thymeleaf-with-spring-security мы объяснили, как атаки CSRF
влияют на приложение Spring MVC. В этой статье будут рассмотрены различные случаи, чтобы определить, может ли REST API
без сохранения состояния (stateless) быть уязвимым для атак CSRF, и если да, то как защитить его от них.

________________________________________________________________________________________________________________________
*** Требуется ли REST API защита CSRF? ***

Во-первых, мы можем найти пример CSRF-атаки в нашем специальном руководстве -
https://www.baeldung.com/spring-security-csrf#example или DOC/CSRF/CSRFGuideProtection.txt данного раздела.

Теперь, прочитав это руководство, мы можем подумать, что REST API без сохранения состояния не будет затронут такого
рода атакой, поскольку на стороне сервера нет сеанса, который можно было бы украсть. Но, давайте возьмем типичный
пример: приложение Spring REST API и клиент Javascript.

Клиент использует безопасный токен в качестве учетных данных (например, JSESSIONID или JWT), который REST API выдает
после успешного входа пользователя.

Уязвимость CSRF зависит от того, как клиент хранит и отправляет эти учетные данные в API.

________________________________________________________________________________________________________________________
*** Учетные данные не сохраняются ***

Получив токен из REST API, мы можем установить его как глобальную переменную JavaScript. При этом токен сохранится
в памяти браузера, и он будет доступен только для текущей страницы. Это наиболее безопасный способ: атаки CSRF и XSS
всегда приводят к открытию клиентского приложения на новой странице, которая не имеет доступа к памяти исходной
страницы, используемой для входа.

Однако нашему пользователю придется входить в систему заново каждый раз, когда он заходит на страницу или обновляет ее.
В мобильных браузерах это произойдет, даже если браузер перейдет в фоновый режим, поскольку система очищает память.
Это настолько ограничивает пользователя, что эта опция реализуется редко.

________________________________________________________________________________________________________________________
*** Учетные данные, хранящиеся в хранилище браузера ***

Мы можем сохранить наш токен в хранилище браузера — например, в хранилище сеансов. Затем наш JavaScript-клиент может
прочитать из него токен и отправить заголовок авторизации с этим токеном во всех запросах REST. Это распространенный
способ использования, например, JWT: он прост в реализации и не позволяет злоумышленникам использовать CSRF-атаки.

Действительно, в отличие от файлов cookie, переменные хранилища браузера не отправляются автоматически на сервер.
Однако эта реализация уязвима для XSS-атак: вредоносный код JavaScript может получить доступ к хранилищу браузера
и отправить токен вместе с запросом. В этом случае мы должны защитить наше приложение -
https://www.baeldung.com/spring-prevent-xss.

________________________________________________________________________________________________________________________
*** Учетные данные, хранящиеся в файлах cookie ***

Другой вариант — использовать файл cookie для сохранения учетных данных. Тогда уязвимость нашего приложения зависит от
того, как наше приложение использует файлы cookie. Мы можем использовать файл cookie только для сохранения учетных
данных, например JWT, но не для аутентификации пользователя.

Наш клиент JavaScript должен будет прочитать токен и отправить его API в заголовке авторизации.

В этом случае наше приложение не уязвимо для CSRF: даже если файл cookie отправляется автоматически по вредоносному
запросу, наш REST API будет считывать учетные данные из заголовка авторизации, а не из файла cookie. Однако флаг
«HTTP-only» должен быть установлен в значение «false», чтобы наш клиент мог прочитать файл cookie.

Однако в этом случае наше приложение будет уязвимо для XSS-атак, как описано в предыдущем разделе!!!

Альтернативный подход — аутентифицировать запросы из файла cookie сеанса, установив для флага «HTTP-only» значение true.
Обычно это то, что Spring Security предоставляет с помощью файла cookie JSESSIONID. Конечно, чтобы сохранить состояние
нашего API, мы никогда не должны использовать сеанс на стороне сервера.

В этом случае наше приложение уязвимо для CSRF, как приложение с отслеживанием состояния: поскольку файл cookie будет
отправляться автоматически с любыми запросами REST, щелчок по вредоносной ссылке может выполнить операции с проверкой
подлинности.

________________________________________________________________________________________________________________________
*** Другие уязвимые конфигурации CSRF ***

Некоторые конфигурации не используют безопасные токены в качестве учетных данных, но также могут быть уязвимы для атак
CSRF. Это случай базовой аутентификации HTTP - https://en.wikipedia.org/wiki/Basic_access_authentication,
дайджест-аутентификации HTTP - https://en.wikipedia.org/wiki/Digest_access_authentication и mTLS -
https://en.wikipedia.org/wiki/Mutual_authentication.

Они не очень распространены, но имеют один и тот же недостаток: браузер автоматически отправляет учетные данные при
любых HTTP-запросах. В этих случаях мы должны включить защиту CSRF.

________________________________________________________________________________________________________________________
*** Отключите защиту CSRF при загрузке Spring ***

Spring Security по умолчанию включает защиту CSRF, начиная с версии 4. Если наш проект не требует этого, мы можем
отключить его в компоненте SecurityFilterChain:

************************************************************************************************************************
@Configuration
public class SpringBootSecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable();
        return http.build();
    }
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Включите защиту CSRF с помощью REST API ***

*** Spring конфигурация ***

Если нашему проекту требуется защита CSRF, мы можем отправить токен CSRF с файлом cookie, используя
CookieCsrfTokenRepository в компоненте SecurityFilterChain. Мы должны установить для флага «HTTP-only» значение false,
чтобы иметь возможность получить его от нашего клиента JavaScript:

************************************************************************************************************************
@Configuration
public class SpringSecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
        return http.build();
    }
}
************************************************************************************************************************

После перезапуска приложения наши запросы получают ошибки HTTP, что означает, что защита CSRF включена. Мы можем
подтвердить, что эти ошибки возникают из класса CsrfFilter, настроив уровень журнала на DEBUG:

************************************************************************************************************************
<logger name="org.springframework.security.web.csrf" level="DEBUG" />
************************************************************************************************************************

Он отобразит:

************************************************************************************************************************
Invalid CSRF token found for http://...
************************************************************************************************************************

Кроме того, мы должны увидеть в нашем браузере наличие нового файла cookie XSRF-TOKEN. Давайте добавим пару строк в
наш REST-контроллер, чтобы также записывать информацию в журналы API:

************************************************************************************************************************
CsrfToken token = (CsrfToken) request.getAttribute("_csrf");
LOGGER.info("{}={}", token.getHeaderName(), token.getToken());
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Конфигурация клиента ***

В клиентском приложении файл cookie XSRF-TOKEN устанавливается после первого доступа к API. Мы можем получить его,
используя регулярное выражение JavaScript:

************************************************************************************************************************
const csrfToken = document.cookie.replace(/(?:(?:^|.*;\s*)XSRF-TOKEN\s*\=\s*([^;]*).*$)|^.*$/, '$1');
************************************************************************************************************************

Затем мы должны отправлять токен на каждый запрос REST, который изменяет состояние API: POST, PUT, DELETE и PATCH.
Spring ожидает получить его в заголовке X-XSRF-TOKEN. Мы можем просто установить его с помощью API JavaScript Fetch:

************************************************************************************************************************
fetch(url, {
    method: 'POST',
    body: JSON.stringify({ /* data to send */ }),
    headers: { 'X-XSRF-TOKEN': csrfToken },
})
************************************************************************************************************************

Теперь мы видим, что наш запрос работает, и ошибка «Неверный токен CSRF» исчезла в журналах REST API. Следовательно,
злоумышленники не смогут провести CSRF-атаку. Например, скрипт, который пытается выполнить тот же запрос с
мошеннического веб-сайта, получит ошибку «Неверный токен CSRF».

Действительно, если пользователь сначала не посетил реальный веб-сайт, файл cookie не будет установлен, и запрос
завершится неудачно.

________________________________________________________________________________________________________________________
*** ИТОГ ***

В этой статье мы рассмотрели различные контексты, в которых возможны или нет CSRF-атаки на REST API.
Затем мы узнали, как включить или отключить защиту CSRF с помощью Spring Security.