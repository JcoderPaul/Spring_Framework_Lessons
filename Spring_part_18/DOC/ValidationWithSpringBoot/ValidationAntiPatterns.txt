См. исходник (ENG): https://reflectoring.io/bean-validation-anti-patterns/
GITHUB автора статьи с примерами: https://github.com/thombergs/code-examples/tree/master/spring-boot/validation
________________________________________________________________________________________________________________________
****** Анти-шаблоны проверки компонентов ******

Bean Validation - это де-факто стандарт для реализации логики проверки в экосистеме Java, и это отличный инструмент,
который нужно иметь под рукой. Однако в недавних проектах я немного глубже задумался о проверке компонентов и выявил
некоторые практики, которые я считаю антишаблонами.
________________________________________________________________________________________________________________________
*** Отказ от ответственности против шаблонов ***

Как и в любом обсуждении шаблонов и антишаблонов, здесь учитываются мнения и личный опыт. Антишаблон в одном контексте
вполне может быть лучшей практикой в другом контексте (и наоборот), поэтому, пожалуйста, не воспринимайте приведенное
ниже обсуждение как религиозные правила, а как повод для размышлений и конструктивного обсуждения этой темы.
________________________________________________________________________________________________________________________

________________________________________________________________________________________________________________________
*** Антишаблон №1: проверка только на уровне персистентности ***

С помощью Spring очень легко настроить проверку компонентов на уровне персистентности. Предположим, у нас есть объект с
некоторыми аннотациями проверки bean-компонентов и связанным с ним репозиторием Spring Data:

************************************************************************************************************************
@Entity
public class Person {

  @Id
  @GeneratedValue
  private Long id;

  @NotEmpty
  private String name;

  @NotNull
  @Min(0)
  private Integer age;

  // getters and setters omitted
}
************************************************************************************************************************

и

************************************************************************************************************************
public interface PersonRepository extends CrudRepository<Person, Long> {

  // default CRUD methods provided by CrudRepository
}
************************************************************************************************************************

Пока у нас есть реализация проверки bean-компонента, такая, как Hibernate Validator, в пути к классам, каждый вызов
метода репозитория *.save() будет запускать проверку. Если состояние переданного Input объекта недопустимо в
соответствии с аннотациями проверки компонента, ConstraintViolationException будет выброшено исключение.

Все идет нормально. Это довольно легко настроить, и зная, что все будет проверено перед отправкой в базу данных, мы
обретаем чувство безопасности. Но, является ли уровень персистентности подходящим местом для проверки? Я думаю, что
это, по крайней мере, не должно быть единственным местом для проверки.

В обычном веб-приложении уровень сохраняемости является самым нижним уровнем. Обычно у нас есть бизнес-уровень и
веб-уровень выше. Данные передаются на веб-уровень, через бизнес-уровень и, наконец, попадают на уровень
персистентности.

Если мы проверяем только на уровне персистентности, мы принимаем на себя риск того, что веб-уровень и бизнес-уровень
будут работать с недействительными данными! Неверные данные могут привести к серьезным ошибкам на бизнес-уровне (если
мы ожидаем, что данные на бизнес-уровне верны) или к сверх-защитному программированию с ручными проверками,
разбросанными по всему бизнес-уровне (как только мы узнаем, что данным в бизнес-уровне нельзя доверять).

В заключение, входные данные для бизнес-уровня уже должны быть действительными. Проверка на уровне персистентности
может тогда выступать в качестве дополнительной системы безопасности, но не как единственное место для проверки.

________________________________________________________________________________________________________________________
*** Антипаттерн №2: проверка с помощью дробовика ***

Однако вместо того, чтобы проверять слишком мало, мы, безусловно, можем подтвердить слишком многое. Это проблема не
только валидации компонентов, но и валидации в целом:
- Данные проверяются с помощью Bean Validation, прежде чем они попадают в систему через веб-уровень.
- Веб-контроллер преобразует входящие данные в объект, который можно передать бизнес-сервису.
- Бизнес-служба не доверяет веб-слою, поэтому она снова проверяет этот объект с помощью проверки компонентов.

Прежде чем выполнить реальную бизнес-логику, бизнес-служба программно проверяет каждое ограничение, которое мы можем
придумать, чтобы абсолютно ничто не могло пойти не так. Наконец, уровень персистентности еще раз проверяет данные перед
их сохранением в базе данных.

Эта «дробовая проверка» может показаться хорошим защитным подходом к проверке, но, по моему опыту, она приводит к
большему количеству проблем, чем к выгоде:
- Во-первых, если мы используем Bean Validation во многих местах, у нас повсюду будут аннотации Bean Validation.
  В случае сомнений мы добавим к объекту аннотации Bean Validation, даже если в конце концов он может не пройти
  валидацию. В конце концов, мы тратим время на добавление и изменение правил проверки, которые в конечном итоге
  могут даже не выполняться.
- Во-вторых, валидация повсюду приводит к созданию правил валидации с благими намерениями, но в конечном итоге
  неверных. Представьте, что мы проверяем, чтобы имя и фамилия человека содержали минимум три символа. Это не
  было обязательным требованием, но мы все равно добавили эту проверку, поскольку отсутствие проверки в нашей
  среде считается грубым. Когда-нибудь мы получим отчет об ошибке, в котором будет сказано, что человек по имени
  «Эд Ширан» не смог зарегистрироваться в нашей системе и только что устроил дерьмовую бурю в Твиттере.

________________________________________________________________________________________________________________________
* Мы всегда делали это таким образом *

Как вы, возможно, заметили, веским аргументом в пользу проверки дробовика является «потому что мы всегда делали это
таким образом». Когда разработчики в вашей команде оправдывают любое решение этим аргументом, я разрешаю им дать
пощечину - в первый раз будьте осторожны.
________________________________________________________________________________________________________________________

- В-третьих, повсеместная валидация замедляет разработку. Если у нас есть правила проверки, разбросанные по всей базе
  кода, некоторые в аннотациях проверки компонентов, а некоторые в простом коде, некоторые из них могут мешать новой
  функции, которую мы создаем. Но мы не можем просто удалить эти проверки, не так ли? В конце концов, кто-то, должно
  быть, положил их туда не просто так. Если мы используем инфляционную валидацию, эта причина часто звучит так: «потому
  что мы всегда делали это таким образом», но мы не можем быть уверены, что в этом нет ничего особенного.
  Мы замедляемся, потому что нам приходится продумывать каждую проверку, прежде чем мы сможем применить наши изменения.

- В-четвертых, поскольку правила проверки пронизаны по всему коду, если мы столкнемся с неожиданной ошибкой проверки,
  мы не знаем, где искать ее исправление. Нам нужно выяснить, где была запущена проверка, что может оказаться
  затруднительным, если мы используем проверку компонентов декларативно с помощью @Validated и @Valid. Затем нам нужно
  просмотреть наши объекты, чтобы найти ответственную аннотацию проверки компонента. Это особенно сложно с вложенными
  объектами.

Короче говоря, вместо того, чтобы проверять все и везде, нам следует иметь четкую и целенаправленную стратегию проверки.

________________________________________________________________________________________________________________________
*** Антипаттерн №3: Использование групп проверки для проверки вариантов использования ***

JSR Bean Validation предоставляет функцию, называемую группами проверки. Эта функция позволяет нам связывать аннотации
проверки с определенными группами, чтобы мы могли выбирать, какую группу проверять:

************************************************************************************************************************
public class Person {

  @Null(groups = ValidateForCreate.class)
  @NotNull(groups = ValidateForUpdate.class)
  private Long id;

  @NotEmpty
  private String name;

  @NotNull
  @Min(value = 18, groups = ValidateForAdult.class)
  @Min(value = 0, groups = ValidateForChild.class)
  private int age;

  // getters and setters omitted
}
************************************************************************************************************************

Когда Person проверяется на создание, у id ожидается, что поле будет иметь значение null. Если обновление подтверждено,
то id ожидается, что поле не будет нулевым.

Аналогично, когда a Person проверяется в варианте использования, который предполагает, что человек будет взрослым,
ожидается, что его минимальный возраст будет равен 18. Если он проверен как ребенок, вместо этого ожидается, что
возраст будет больше 0.

Эти проверки запускаются в сценарии использования путем указания того, какие группы мы хотим проверить:

************************************************************************************************************************
@Service
@Validated
class RegisterPersonService {

  @Validated({ValidateForAdult.class, ValidateForCreate.class})
  void registerAdult(@Valid Person person) {
    // do something
  }

  @Validated({ValidateForChild.class, ValidateForCreate.class})
  void registerChild(@Valid Person person) {
    // do something
  }
}
************************************************************************************************************************

Аннотация @Validated - это аннотация Spring, которая проверяет входные данные метода перед его вызовом, но группы
проверки также можно использовать без Spring.

Итак, что не так с группами проверки?

Прежде всего, мы намеренно нарушаем принцип единой ответственности. Класс Person модели знает правила проверки для всех
случаев использования, для которых он проверен. Класс модели должен измениться, если изменится проверка, специфичная для
определенного варианта использования.

- Во-вторых, это просто трудно читать. Приведенный выше пример пока прост, но вы можете себе представить, что его
становится все труднее понять из-за большего количества вариантов использования и полей. Читать становится еще
труднее, если мы используем аннотацию @ConvertGroup, которая позволяет конвертировать одну группу в другую для
вложенного объекта.

Вместо использования групп проверки я предлагаю следующее:
- Используйте аннотации Bean Validation только для синтаксической проверки, которая применима ко всем вариантам
  использования.
- Добавьте методы запроса семантической информации в класс модели. В приведенном выше случае мы бы добавили методы
  hasId() и isAdult().
- В коде варианта использования вызовите эти методы запроса, чтобы семантически проверить данные для варианта
  использования.

Таким образом, семантика конкретного варианта использования проверяется в коде варианта использования, которому они
принадлежат, и код модели не зависит от варианта использования. В то же время бизнес-правила по-прежнему закодированы
в «насыщенном» классе модели предметной области и доступны через методы запроса.

________________________________________________________________________________________________________________________
*** Подтверждайте сознательно ***

Проверка компонентов — это отличный инструмент, который всегда под рукой, но с хорошими инструментами приходит большая
ответственность (звучит немного банально, но, если вы спросите меня, это то, что нужно). Вместо того, чтобы использовать
проверку Bean для всего и проверять везде, мы должны иметь четкую стратегию проверки, которая говорит нам, где проверять
и когда использовать какой инструмент для проверки.

Нам следует отделить синтаксическую проверку от семантической проверки. Синтаксическая проверка — идеальный вариант
использования декларативного стиля, поддерживаемого аннотациями Bean Validation, тогда как семантическая проверка лучше
читается в простом коде.