См. исходник (ENG): https://reflectoring.io/bean-validation-with-spring-boot/
GITHUB с примерами для статьи: https://github.com/thombergs/code-examples/tree/master/spring-boot/validation
________________________________________________________________________________________________________________________
****** Валидация с помощью Spring Boot — полное руководство ******

Проверка компонентов является стандартом де-факто для реализации логики проверки в экосистеме Java. Она хорошо
интегрирована со Spring и Spring Boot см. https://beanvalidation.org/

Однако есть некоторые подводные камни. В этом руководстве рассматриваются все основные варианты использования проверки
и примеры кода для каждого из них: https://github.com/thombergs/code-examples/tree/master/spring-boot/validation

________________________________________________________________________________________________________________________
*** Использование Spring Boot Validation Starter ***

Поддержка проверки компонентов Spring Boot включает в себя средство запуска проверки, которое мы можем включить в наш
проект (нотация Gradle):

************************************************************************************************************************
implementation('org.springframework.boot:spring-boot-starter-validation')
************************************************************************************************************************

Нет необходимости добавлять номер версии, поскольку плагин Spring Dependency Management Gradle делает это за нас. Если
вы не используете плагин, самую последнюю версию можно найти здесь:
https://central.sonatype.com/search?q=g:org.springframework.boot%20%20a:spring-boot-starter-validation&core=gav&smo=true

Однако, если мы также включили веб-стартер, стартер проверки подтянется транзитивно:

************************************************************************************************************************
implementation('org.springframework.boot:spring-boot-starter-web')
************************************************************************************************************************

Обратите внимание, что средство запуска проверки не более чем добавляет зависимость к совместимой версии hibernate
validator, которая является наиболее широко используемой реализацией спецификации Bean Validation.

________________________________________________________________________________________________________________________
*** Основы проверки компонентов ***

По сути, проверка компонентов работает путем определения ограничений для полей класса путем аннотирования их
определенными аннотациями.

* Общие аннотации проверки *

Некоторые из наиболее распространенных аннотаций проверки:
- @NotNull: сказать, что поле не должно быть нулевым.
- @NotEmpty: сказать, что поле списка не должно быть пустым.
- @NotBlank: сказать, что строковое поле не должно быть пустой строкой (т.е. оно должно содержать хотя бы один символ).
- @Min и @Max: сказать, что числовое поле действительно только тогда, когда его значение выше или ниже определенного
               значения.
- @Pattern: сказать, что строковое поле действительно только в том случае, если оно соответствует определенному
            регулярному выражению.
- @Email: сказать, что строковое поле должно быть действительным адресом электронной почты.

Пример такого класса будет выглядеть так:

************************************************************************************************************************
class Customer {

  @Email
  private String email;

  @NotBlank
  private String name;

  // ...
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Validator - Валидатор ***

Чтобы проверить корректность объекта, мы передаем его валидатору, который проверяет, выполняются ли ограничения:

************************************************************************************************************************
Set<ConstraintViolation<Input>> violations = validator.validate(customer);
if (!violations.isEmpty()) {
  throw new ConstraintViolationException(violations);
}
************************************************************************************************************************

Подробнее об использовании Validator см. ниже.

________________________________________________________________________________________________________________________
*** @Validated и @Valid ***

Во многих случаях Spring выполняет проверку за нас. Нам даже не нужно самостоятельно создавать объект валидатора.
Вместо этого мы можем сообщить Spring, что мы хотим проверить определенный объект. Это работает с использованием
аннотаций @Validated и @Valid.

Аннотация @Validated - это аннотация уровня класса, которую мы можем использовать, чтобы сообщить Spring о
                       необходимости проверки параметров, передаваемых в метод аннотированного класса. Мы
                       узнаем больше о том, как его использовать, в разделе о проверке переменных пути и
                       параметров запроса см. ниже.

Аннотация @Valid - применяется к параметрам и полям метода, чтобы сообщить Spring, что мы хотим, чтобы параметр
                   или поле метода были проверены. Все об этой аннотации мы узнаем в разделе о проверке тела
                   запроса см. ниже.

________________________________________________________________________________________________________________________
*** Проверка входных данных в контроллере Spring MVC ***

Допустим, мы реализовали контроллер Spring REST и хотим проверить входные данные, переданные клиентом. Есть три вещи,
которые мы можем проверить для любого входящего HTTP-запроса:
- тело запроса;
- переменные внутри пути (например, idв /foos/{id});
- параметры запроса;

Давайте рассмотрим каждый из них более подробно.

________________________________________________________________________________________________________________________
* Проверка тела запроса *

В запросах POST и PUT полезные данные JSON обычно передаются в теле запроса. Spring автоматически сопоставляет входящий
JSON с объектом Java. Теперь мы хотим проверить, соответствует ли входящий объект Java нашим требованиям.

Это наш класс входящей полезной нагрузки:

************************************************************************************************************************
class Input {

  @Min(1)
  @Max(10)
  private int numberBetweenOneAndTen;

  @Pattern(regexp = "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$")
  private String ipAddress;

  // ...
}
************************************************************************************************************************

У нас есть int поле, которое должно иметь значение от 1 до 10 включительно, как определено аннотациями @Min и @Max. У
нас также есть String поле, которое должно содержать IP-адрес, как определено регулярным выражением в аннотации @Pattern
(на самом деле регулярное выражение по-прежнему допускает недопустимые IP-адреса с октетами больше 255, но мы собираемся
исправить это чуть позже см. ниже, когда мы создаем собственный валидатор).

Чтобы проверить тело входящего HTTP-запроса, мы аннотируем тело запроса аннотацией @Valid в контроллере REST:

************************************************************************************************************************
@RestController
class ValidateRequestBodyController {

  @PostMapping("/validateBody")
  ResponseEntity<String> validateBody(@Valid @RequestBody Input input) {
    return ResponseEntity.ok("valid");
  }

}
************************************************************************************************************************

Мы просто добавили @Valid аннотацию к Input параметру, который также помечен значком, @RequestBody обозначающим, что его
следует читать из тела запроса. Делая это, мы говорим Spring передать объект, Validator прежде чем делать что-либо еще.

________________________________________________________________________________________________________________________
* Использование @Valid со сложными типами *

Если Input класс содержит поле другого сложного типа, которое необходимо проверить, это поле также необходимо пометить
@Valid. Если проверка не удалась, она вызовет MethodArgumentNotValidException. По умолчанию Spring преобразует это
исключение в статус HTTP 400 (неверный запрос).

Мы можем проверить это поведение с помощью интеграционного теста:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@WebMvcTest(controllers = ValidateRequestBodyController.class)
class ValidateRequestBodyControllerTest {

  @Autowired
  private MockMvc mvc;

  @Autowired
  private ObjectMapper objectMapper;

  @Test
  void whenInputIsInvalid_thenReturnsStatus400() throws Exception {
    Input input = invalidInput();
    String body = objectMapper.writeValueAsString(input);

    mvc.perform(post("/validateBody")
            .contentType("application/json")
            .content(body))
            .andExpect(status().isBadRequest());
  }
}
************************************************************************************************************************

Более подробно о тестировании контроллеров Spring MVC вы можете найти в статье про @WebMvcTest аннотацию см. (ENG):
https://reflectoring.io/spring-boot-web-controller-test/

________________________________________________________________________________________________________________________
*** Проверка переменных пути и параметров запроса ***

Проверка переменных пути и параметров запроса работает немного по-другому. В этом случае мы не проверяем сложные
объекты Java, поскольку переменные пути и параметры запроса являются примитивными типами, например, int или их
аналогами, такими как Integer или String.

Вместо аннотации поля класса, как указано выше, мы добавляем аннотацию ограничения (в данном случае @Min)
непосредственно к параметру метода в контроллере Spring:

************************************************************************************************************************
@RestController
@Validated
class ValidateParametersController {

  @GetMapping("/validatePathVariable/{id}")
  ResponseEntity<String> validatePathVariable(
      @PathVariable("id") @Min(5) int id) {
    return ResponseEntity.ok("valid");
  }

  @GetMapping("/validateRequestParameter")
  ResponseEntity<String> validateRequestParameter(
      @RequestParam("param") @Min(5) int param) {
    return ResponseEntity.ok("valid");
  }
}
************************************************************************************************************************

Обратите внимание, что нам нужно добавить @Validated аннотацию Spring к контроллеру на уровне класса, чтобы сообщить
Spring оценить аннотации ограничений для параметров метода. В этом случае аннотация @Validated оценивается только на
уровне класса, хотя ее разрешено использовать в методах.

В отличие от проверки тела запроса, при неудачной проверке ConstraintViolationException вместо
MethodArgumentNotValidException. Spring не регистрирует обработчик исключений по умолчанию для этого исключения,
поэтому по умолчанию он вызывает ответ со статусом HTTP 500 (внутренняя ошибка сервера).

Если вместо этого мы хотим вернуть HTTP-статус 400 (что имеет смысл, поскольку клиент предоставил недопустимый параметр,
что делает запрос неверным), мы можем добавить собственный обработчик исключений в наш контроллер:

************************************************************************************************************************
@RestController
@Validated
class ValidateParametersController {

  // request mapping method omitted

  @ExceptionHandler(ConstraintViolationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  ResponseEntity<String> handleConstraintViolationException(ConstraintViolationException e) {
    return new ResponseEntity<>("not valid due to validation error: " + e.getMessage(), HttpStatus.BAD_REQUEST);
  }
}
************************************************************************************************************************

Позже в этом руководстве мы рассмотрим, как вернуть структурированный ответ об ошибке, содержащий подробную информацию
обо всех неудачных проверках, которые клиент должен проверить. Мы можем проверить поведение проверки с помощью
интеграционного теста:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@WebMvcTest(controllers = ValidateParametersController.class)
class ValidateParametersControllerTest {

  @Autowired
  private MockMvc mvc;

  @Test
  void whenPathVariableIsInvalid_thenReturnsStatus400() throws Exception {
    mvc.perform(get("/validatePathVariable/3"))
            .andExpect(status().isBadRequest());
  }

  @Test
  void whenRequestParameterIsInvalid_thenReturnsStatus400() throws Exception {
    mvc.perform(get("/validateRequestParameter")
            .param("param", "3"))
            .andExpect(status().isBadRequest());
  }
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Проверка входных данных для метода службы Spring ***

Вместо (или в дополнение к) проверки входных данных на уровне контроллера мы также можем проверять входные данные для
любых компонентов Spring. Для этого мы используем комбинацию аннотаций @Validated и @Valid:

************************************************************************************************************************
@Service
@Validated
class ValidatingService{

    void validateInput(@Valid Input input){
      // do something
    }
}
************************************************************************************************************************

Опять же, @Validated аннотация оценивается только на уровне класса, поэтому в этом случае не помещайте ее в метод. Вот
тест, проверяющий поведение проверки:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@SpringBootTest
class ValidatingServiceTest {

  @Autowired
  private ValidatingService service;

  @Test
  void whenInputIsInvalid_thenThrowsException(){
    Input input = invalidInput();

    assertThrows(ConstraintViolationException.class, () -> {
      service.validateInput(input);
    });
  }
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Проверка объектов JPA ***

Последней линией защиты при проверке является уровень персистентности. По умолчанию Spring Data использует Hibernate,
который поддерживает проверку компонентов «из коробки».

Является ли уровень персистентности подходящим местом для проверки?

Обычно мы не хотим выполнять проверку только на уровне персистентности, поскольку это означает, что приведенный выше
бизнес-код работал с потенциально недопустимыми объектами, что может привести к непредвиденным ошибкам. Подробнее на
эту тему в моей статье про антишаблоны Bean Validation см.:
https://reflectoring.io/bean-validation-anti-patterns/#anti-pattern-1-validating-only-in-the-persistence-layer

Допустим, вы хотите сохранить объекты нашего Input класса в базе данных. Сначала мы добавляем необходимую аннотацию JPA
@Entity и добавляем поле ID:

************************************************************************************************************************
@Entity
public class Input {

  @Id
  @GeneratedValue
  private Long id;

  @Min(1)
  @Max(10)
  private int numberBetweenOneAndTen;

  @Pattern(regexp = "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$")
  private String ipAddress;

  // ...
}
************************************************************************************************************************

Затем мы создаем репозиторий Spring Data, который предоставляет нам методы для сохранения и запроса Input объектов:

************************************************************************************************************************
public interface ValidatingRepository extends CrudRepository<Input, Long> {}
************************************************************************************************************************

По умолчанию каждый раз, когда мы используем репозиторий для хранения объекта Input, аннотации ограничений которого
нарушены, мы получаем ConstraintViolationException, как показывает этот интеграционный тест:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@DataJpaTest
class ValidatingRepositoryTest {

  @Autowired
  private ValidatingRepository repository;

  @Autowired
  private EntityManager entityManager;

  @Test
  void whenInputIsInvalid_thenThrowsException() {
    Input input = invalidInput();

    assertThrows(ConstraintViolationException.class, () -> {
      repository.save(input);
      entityManager.flush();
    });
  }
}
************************************************************************************************************************

Более подробно о тестировании репозиториев Spring Data вы можете найти в моей статье об @DataJpaTest аннотации см.:
https://reflectoring.io/spring-boot-data-jpa-test/

!!! Обратите внимание !!! Проверка bean-компонента запускается Hibernate только после его EntityManager очистки.
                          Hibernate автоматически очищает их EntityManager при определенных обстоятельствах, но
                          в случае нашего интеграционного теста нам придется делать это вручную.

Если по какой-либо причине мы хотим отключить проверку компонентов в наших репозиториях Spring Data, мы можем
установить spring.jpa.properties.javax.persistence.validation.modeдля свойства Spring Boot значение - none.

________________________________________________________________________________________________________________________
*** Пользовательский валидатор с Spring Boot ***

Если доступных аннотаций ограничений недостаточно для наших случаев использования, мы можем создать их самостоятельно.
В Input приведенном выше классе мы использовали регулярное выражение для проверки того, что строка является
действительным IP-адресом. Однако регулярное выражение не является полным: оно допускает октеты со значениями больше
255 (т.е. «111.111.111.333» будет считаться действительным).

Давайте исправим это, реализовав валидатор, реализующий эту проверку на Java, а не с помощью регулярного выражения
(да, я знаю, что мы могли бы просто использовать более сложное регулярное выражение для достижения того же результата,
но нам нравится реализовывать проверки на Java, правда же?).

Сначала мы создаем пользовательскую аннотацию ограничения IpAddress:

************************************************************************************************************************
@Target({ FIELD })
@Retention(RUNTIME)
@Constraint(validatedBy = IpAddressValidator.class)
@Documented
public @interface IpAddress {

  String message() default "{IpAddress.invalid}";

  Class<?>[] groups() default { };

  Class<? extends Payload>[] payload() default { };

}
************************************************************************************************************************

Пользовательская аннотация ограничения требует следующего:
- параметр message, указывающий на ключ свойства в ValidationMessages.properties, который используется для разрешения
  сообщения в случае нарушения;
- параметр groups, позволяет определить, при каких обстоятельствах должна запускаться эта проверка (о группах проверки
  groups мы поговорим позже);
- параметр payload, позволяет определить полезную нагрузку, которая будет передана при этой проверке (поскольку это
  редко используемая функция, мы не будем рассматривать ее в этом руководстве);
- аннотация @Constraint, указывающая на реализацию интерфейса ConstraintValidator.

Реализация валидатора выглядит следующим образом:

************************************************************************************************************************
class IpAddressValidator implements ConstraintValidator<IpAddress, String> {

  @Override
  public boolean isValid(String value, ConstraintValidatorContext context) {
    Pattern pattern =
      Pattern.compile("^([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$");
    Matcher matcher = pattern.matcher(value);
    try {
      if (!matcher.matches()) {
        return false;
      } else {
        for (int i = 1; i <= 4; i++) {
          int octet = Integer.valueOf(matcher.group(i));
          if (octet > 255) {
            return false;
          }
        }
        return true;
      }
    } catch (Exception e) {
      return false;
    }
  }
}
************************************************************************************************************************

Теперь мы можем использовать эту @IpAddress аннотацию так же, как и любую другую аннотацию ограничения:

************************************************************************************************************************
class InputWithCustomValidator {

  @IpAddress
  private String ipAddress;

  // ...
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Программная проверка ***

Могут быть случаи, когда мы хотим вызвать проверку программно, вместо того, чтобы полагаться на встроенную поддержку
проверки компонентов Spring. В этом случае мы можем напрямую использовать API проверки компонентов.

Мы создаем Validator вручную и вызываем его для запуска проверки:

************************************************************************************************************************
class ProgrammaticallyValidatingService {

  void validateInput(Input input) {
    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
    Validator validator = factory.getValidator();
    Set<ConstraintViolation<Input>> violations = validator.validate(input);
    if (!violations.isEmpty()) {
      throw new ConstraintViolationException(violations);
    }
  }
}
************************************************************************************************************************

Для этого не требуется никакой поддержки Spring. Однако Spring Boot предоставляет нам предварительно настроенный
экземпляр Validator-a. Мы можем внедрить этот экземпляр в наш сервис и использовать его вместо того, чтобы создавать
его вручную:

************************************************************************************************************************
@Service
class ProgrammaticallyValidatingService {

  private Validator validator;

  ProgrammaticallyValidatingService(Validator validator) {
    this.validator = validator;
  }

  void validateInputWithInjectedValidator(Input input) {
    Set<ConstraintViolation<Input>> violations = validator.validate(input);
    if (!violations.isEmpty()) {
      throw new ConstraintViolationException(violations);
    }
  }
}
************************************************************************************************************************

Когда Spring создает экземпляр этой службы, ее экземпляр автоматически добавляется Validator в конструктор. Следующий
модульный тест доказывает, что оба описанных выше метода работают должным образом:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@SpringBootTest
class ProgrammaticallyValidatingServiceTest {

  @Autowired
  private ProgrammaticallyValidatingService service;

  @Test
  void whenInputIsInvalid_thenThrowsException(){
    Input input = invalidInput();

    assertThrows(ConstraintViolationException.class, () -> {
      service.validateInput(input);
    });
  }

  @Test
  void givenInjectedValidator_whenInputIsInvalid_thenThrowsException(){
    Input input = invalidInput();

    assertThrows(ConstraintViolationException.class, () -> {
      service.validateInputWithInjectedValidator(input);
    });
  }
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
*** Использование групп проверки для проверки объектов по-разному для разных случаев использования ***

Часто определенные объекты используются совместно в разных вариантах использования. Давайте возьмем, к примеру, типичные
операции CRUD: вариант использования «Создать» и вариант использования «Обновление», скорее всего, оба будут принимать в
качестве входных данных один и тот же тип объекта. Однако могут существовать проверки, которые следует запускать при
различных обстоятельствах:
- только в варианте использования «Создать»;
- только в варианте использования «Обновление»;
- в обоих случаях использования;

Функция проверки компонентов, которая позволяет нам реализовывать подобные правила проверки, называется -
«Группы проверки». Мы уже видели, что все аннотации ограничений должны иметь поле - groups. Это можно использовать для
передачи любых классов, каждый из которых определяет определенную группу проверки, которая должна быть запущена.

В нашем примере CRUD мы просто определяем два маркерных интерфейса OnCreate и OnUpdate:

************************************************************************************************************************
interface OnCreate {}
************************************************************************************************************************

и

************************************************************************************************************************
interface OnUpdate {}
************************************************************************************************************************

Затем мы можем использовать эти интерфейсы маркеров с любой аннотацией ограничения, например:

************************************************************************************************************************
class InputWithGroups {

  @Null(groups = OnCreate.class)
  @NotNull(groups = OnUpdate.class)
  private Long id;

  // ...
}
************************************************************************************************************************

Это гарантирует, что идентификатор будет пустым в нашем варианте использования «Создать» и что он не будет пустым в
нашем варианте использования «Обновление». Spring поддерживает группы проверки с @Validated аннотацией:

************************************************************************************************************************
@Service
@Validated
class ValidatingServiceWithGroups {

    @Validated(OnCreate.class)
    void validateForCreate(@Valid InputWithGroups input){
      // do something
    }

    @Validated(OnUpdate.class)
    void validateForUpdate(@Valid InputWithGroups input){
      // do something
    }
}
************************************************************************************************************************

Обратите внимание, что @Validated аннотацию снова необходимо применить ко всему классу. Чтобы определить, какая группа
проверки должна быть активной, ее также необходимо применить на уровне метода. Чтобы убедиться, что вышеизложенное
работает должным образом, мы можем реализовать модульный тест:

************************************************************************************************************************
@ExtendWith(SpringExtension.class)
@SpringBootTest
class ValidatingServiceWithGroupsTest {

  @Autowired
  private ValidatingServiceWithGroups service;

  @Test
  void whenInputIsInvalidForCreate_thenThrowsException() {
    InputWithGroups input = validInput();
    input.setId(42L);

    assertThrows(ConstraintViolationException.class, () -> {
      service.validateForCreate(input);
    });
  }

  @Test
  void whenInputIsInvalidForUpdate_thenThrowsException() {
    InputWithGroups input = validInput();
    input.setId(null);

    assertThrows(ConstraintViolationException.class, () -> {
      service.validateForUpdate(input);
    });
  }
}
************************************************************************************************************************

________________________________________________________________________________________________________________________
Будьте осторожны с группами проверки.

Использование групп проверки может легко стать антишаблоном, поскольку мы смешиваем задачи. При использовании групп
проверки проверяемый объект должен знать правила проверки для всех вариантов использования (групп), в которых он
используется. Подробнее об этой теме можно прочитать в моей статье об антишаблонах проверки компонентов см.:
https://reflectoring.io/bean-validation-anti-patterns/
________________________________________________________________________________________________________________________

________________________________________________________________________________________________________________________
*** Обработка ошибок проверки ***

Если проверка не удалась, мы хотим вернуть клиенту значимое сообщение об ошибке. Чтобы клиент мог отображать полезное
сообщение об ошибке, мы должны вернуть структуру данных, содержащую сообщение об ошибке для каждой неудачной проверки.

Во-первых, нам нужно определить эту структуру данных. Мы назовем его ValidationErrorResponse, и он будет содержать
список Violation объектов:

************************************************************************************************************************
public class ValidationErrorResponse {

  private List<Violation> violations = new ArrayList<>();

  // ...
}

public class Violation {

  private final String fieldName;

  private final String message;

  // ...
}
************************************************************************************************************************

Затем мы создаем глобальный объект ControllerAdvice, который обрабатывает все ConstraintViolationExceptions эти пузырьки
вплоть до уровня контроллера. Чтобы отловить ошибки проверки для тела запроса, мы также обработаем
MethodArgumentNotValidExceptions:

************************************************************************************************************************
@ControllerAdvice
class ErrorHandlingControllerAdvice {

  @ExceptionHandler(ConstraintViolationException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  @ResponseBody
  ValidationErrorResponse onConstraintValidationException(
      ConstraintViolationException e) {
    ValidationErrorResponse error = new ValidationErrorResponse();
    for (ConstraintViolation violation : e.getConstraintViolations()) {
      error.getViolations().add(
        new Violation(violation.getPropertyPath().toString(), violation.getMessage()));
    }
    return error;
  }

  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST)
  @ResponseBody
  ValidationErrorResponse onMethodArgumentNotValidException(
      MethodArgumentNotValidException e) {
    ValidationErrorResponse error = new ValidationErrorResponse();
    for (FieldError fieldError : e.getBindingResult().getFieldErrors()) {
      error.getViolations().add(
        new Violation(fieldError.getField(), fieldError.getDefaultMessage()));
    }
    return error;
  }
}
************************************************************************************************************************

Здесь мы просто считываем информацию о нарушениях из исключений и переводим ее в нашу ValidationErrorResponse структуру
данных.

!!! Обратите внимание !!! На @ControllerAdvice аннотацию, которая делает методы обработчика исключений доступными
                          глобально для всех контроллеров в контексте приложения.
________________________________________________________________________________________________________________________
*** Заключение ***

В этом руководстве мы кратко рассмотрели все основные функции проверки, которые могут нам понадобиться при создании
приложения с помощью Spring Boot. Загляните в репозиторий github с примерами:
https://github.com/thombergs/code-examples/tree/master/spring-boot/validation